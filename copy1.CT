<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="38">
  <CheatEntries>
    <CheatEntry>
      <ID>874</ID>
      <Description>"lib"</Description>
      <LastState Activated="1"/>
      <Color>FF0000</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
//00401000~00F01000 api골조 저장소 : 기능,퍼운테이션
//00F02000~01203000 문자열 저장소 //문자열 저장소
//01304000~01404000 배열 저장소 //4바이트마다 더해지는 주소지 저장소
//01404000~01505000 포인터 저장소 //포인터 저장소
//01506000~01607000 변수 저장소 :비교 문구,조건문,카운트,좌표

define(GetModules,00403098) //lib//
Registersymbol(GetModules)//KERNEL32.GetModuleHandleA
define(GProc,00403108) //KERNEL32.GetProcAddress
Registersymbol(GProc)
GetModules:
dd KERNEL32.GetModuleHandleA
GProc:
dd KERNEL32.GetProcAddress

[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>875</ID>
      <Description>"Error DebugX"</Description>
      <LastState Activated="1"/>
      <Color>FF0000</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
define(allocError,1541)
Registersymbol(allocError)//팩토리 방이 할당되지 않음 m_Direct3DObject
[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>876</ID>
      <Description>"--------------------ErrorList--------------------"</Description>
      <LastState Activated="1"/>
      <Color>00FF00</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

 
[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>877</ID>
      <Description>"define(api리스트) //00500000~00F01000 api골조 저장소 : 기능,퍼운테이션"</Description>
      <LastState Activated="1"/>
      <Color>FF0000</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
//00500000~00F01000 api골조 저장소 : 기능,퍼운테이션

 define(main,00500000) //유니코드(한칸 뛰어놔주는 기능
Registersymbol(main)
 define(MChapi,main+1000) //유니코드(한칸 뛰어놔주는 기능
Registersymbol(MChapi)
////////////////////////////문자 변환 api
define(LoginMain,main+2000)
Registersymbol(LoginMain)
////////////////////////////////로그인 api
define(LoginGui,main+3000)
Registersymbol(LoginGui)
define(memsetapi,main+4000)
Registersymbol(memsetapi)
define(Switch,main+5000)
Registersymbol(Switch)
define(malloc24,main+6000)
Registersymbol(malloc24)
define(malloc28,main+8000)
Registersymbol(malloc28)
define(malloc4,main+9000)
Registersymbol(malloc4)
define(Th,main+A000)
Registersymbol(Th)
define(SoundX,main+B000)
Registersymbol(SoundX)
define(factoryCreate3X,main+C000)
Registersymbol(factoryCreate3X)
define(IATGate,main+D000)//api iat
Registersymbol(IATGate)
define(Charmovzero,main+E000)
Registersymbol(Charmovzero)
define(PathDiagram,main+F000)
Registersymbol(PathDiagram)
define(XYDiagram,main+10000)
Registersymbol(XYDiagram)
define(loadImageX,main+11000)
Registersymbol(loadImageX)


define(imageDiagramX,main+13000) //코딩 70줄 이미지 로드 서브 메인
Registersymbol(imageDiagramX)
define(imageDiagramXsub,main+14000) //코딩 70줄 이미지 로드 서브 메인
Registersymbol(imageDiagramXsub)

define(scrinRestart,main+15000) //스크린 리스타트
Registersymbol(scrinRestart)
define(scrinRestartsub,main+16000) //스크린 리스타트
Registersymbol(scrinRestartsub)
define(DirectXMainCon,main+17000) //mainBrushImage
Registersymbol(DirectXMainCon)
define(MouseMovs,main+18000)
Registersymbol(MouseMovs)
define(MetaInza,main+19000)
Registersymbol(MetaInza)
define(diret,main+1A000)
Registersymbol(diret)//BrashFloat1D0
define(LgoinBrush12sub,main+1B000)
Registersymbol(LgoinBrush12sub)//BrashFloat1D0
define(LgoinBrush12,main+1C000)
Registersymbol(LgoinBrush12)//BrashFloat1D0
define(LgoinBrush1,main+1D000)
Registersymbol(LgoinBrush1)//BrashFloat1D0
define(LgoinBrush2,main+1E000)
Registersymbol(LgoinBrush2)//BrashFloat1D0
define(WorldBrushCh,main+1F000)
Registersymbol(WorldBrushCh)//BrashFloat1D0
define(MainMetaX,main+20000) //api
Registersymbol(MainMetaX)//api
define(BrushMainX,main+21000) //api3
Registersymbol(BrushMainX)//api3
define(LgoinSwitchContolo,main+22000) //LgoinSwitch
Registersymbol(LgoinSwitchContolo)//LgoinSwitch
define(operX,main+23000) //LgoinSwitch
Registersymbol(operX)//LgoinSwitch

define(timeCreate,main+24000) //Timerapi
Registersymbol(timeCreate)//Timerapi

define(timerapi2,main+25000) //Timerapi
Registersymbol(timerapi2)//Timerapi

define(ACMent1,main+26000) //Timerapi
Registersymbol(ACMent1)//Timerapi
define(ACMent2,main+27000)
Registersymbol(ACMent2)
define(factoryCreate,main+28000)
Registersymbol(factoryCreate)
/////////////////////////////////////////////////////////
define(GraphicsClassX,main+29000)
Registersymbol(GraphicsClassX)
define(D3DInitialize,main+2A000)
Registersymbol(D3DInitialize)
define(TextureShaderClassDBVM,main+2C000)
Registersymbol(TextureShaderClassDBVM)
define(DXBitmapClassInitialize,main+2D000)
Registersymbol(DXBitmapClassInitialize)
define(CreateDDSTextureFromFileExDBVMX,main+2E000)
Registersymbol(CreateDDSTextureFromFileExDBVMX)
define(ErrorSum,main+2F000)
Registersymbol(ErrorSum)
define(CreateTextureFromDDSDBVM,main+30000)
Registersymbol(CreateTextureFromDDSDBVM)
define(CreateDDSTextureFromFileExDBVMX3,main+31000)
Registersymbol(CreateDDSTextureFromFileExDBVMX3)
define(LoadTextureDataFromFileX,main+32000)
Registersymbol(LoadTextureDataFromFileX)
define(NameSpaceBitsPixelX,main+33000)
Registersymbol(NameSpaceBitsPixelX)
define(GetDXGIFormatDBVM,main+34000)
Registersymbol(GetDXGIFormatDBVM)
define(FillInitDataDBVM,main+35000)
Registersymbol(FillInitDataDBVM)
define(GetSurfaceInfoDBVM,main+36000)
Registersymbol(GetSurfaceInfoDBVM)
define(CreateD3DResourcesDBVM,main+37000)
Registersymbol(CreateD3DResourcesDBVM)
define(RendersX,main+38000)
Registersymbol(RendersX)
define(ThX,main+39000)
Registersymbol(ThX)
define(CameraXDBVM,main+3A000)
Registersymbol(CameraXDBVM)
define(XMMatrixLookToLHDBVM,main+3B000)
Registersymbol(XMMatrixLookToLHDBVM)
[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>878</ID>
      <Description>"define(문자열 리스트) 1.사운드 타입 2.시그너처 영역 //00F02000~01203000 문자열 저장소 //문자열 저장소"</Description>
      <LastState Activated="1"/>
      <Color>FF0000</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]


//00F02000~01203000 문자열 저장소 //문자열 저장소

/////////////////////////////////문자열 식별자/////////////////////////////////문자열 식별자
define(MetaIn1,01112000)
Registersymbol(MetaIn1)//로그인 문자열 출력
define(MetaIn2,01112500)
Registersymbol(MetaIn2)//비밀번호 문자열 출력
define(6CMeta,01113000) //KEYMAIN
Registersymbol(6CMeta)//KEYMAIN
define(logoinSX,01113004) //KEYMAIN
Registersymbol(logoinSX)//KEYMAIN
define(BrashFloat1D0,01114000)
Registersymbol(BrashFloat1D0)//문자열 브러쉬 위치 식별자
/////////////////////////////////문자열 식별자/////////////////////////////////문자열 식별자/////////////////////////////////문자열 식별자
define(6CMeta2,0111f000) //KEYMAIN
Registersymbol(6CMeta2)//KEYMAIN
define(ChnerMenu,0111c000) //KEYSave
Registersymbol(ChnerMenu)//KEYSave
define(KEYSave,01125000) //KEYSave
Registersymbol(KEYSave)//KEYSave
define(KeyCount,01125000-4) //KEYCount
Registersymbol(KeyCount)//KEYCount
define(KEYSwitch,01125000-8) //KEYCount
Registersymbol(KEYSwitch)//KEYCount


define(KEYSave2,01126000) //KEYSave
Registersymbol(KEYSave2)//KEYSave
define(KeyCount2,01126000-4) //KEYCount
Registersymbol(KeyCount2)//KEYCount
define(KEYSwitch2,01126000-8) //KEYCount
Registersymbol(KEYSwitch2)//KEYCount

//////////////////////////시그니처 영역
define(mp3Type,011a4000)//사운드 타입식별자 아이디
Registersymbol(mp3Type)
///////////////////////////////////////GUI
define(WICImagingFactory2,011a4600)//사운드 타입식별자 아이디
Registersymbol(WICImagingFactory2)
define(GUIID,011a4800)//사운드 타입식별자 아이디
Registersymbol(GUIID)
define(GUIFormat,011A4860)
Registersymbol(GUIFormat)

////GUIID LIST
define(metaguiID,011a4900)//사운드 타입식별자 아이디
Registersymbol(metaguiID)
define(factoryGUID,011a49A0)
Registersymbol(factoryGUID)

define(guiDx3ID,011a4BA0)
Registersymbol(guiDx3ID)

define(guiDx3ID2,011a4CA0)
Registersymbol(guiDx3ID2)





define(UnicodeDirect2DX1,011b0020){ ("dx2_ts00") }
Registersymbol(UnicodeDirect2DX1)
define(UnicodeDirect2DX2,011b0040) { ("2_ts00") }
Registersymbol(UnicodeDirect2DX2)
define(UnicodeDirect2DX3,011b0060) { ("2_ts00") }
Registersymbol(UnicodeDirect2DX3)
define(Direct2DKEY,011b0080) { ("2_ts00") }
Registersymbol(Direct2DKEY)
define(pathX,011b00A0)
Registersymbol(pathX)
define(dlllist,011b01A0) //많은양에 속함 +900000까지 사용
Registersymbol(dlllist)


 define(apilist,011c0000) //기본문자열
Registersymbol(apilist) //
 define(IAT,011D0000) //기본문자열
Registersymbol(IAT) //


define(DX3ME1,011E0000) //vs_5_0
Registersymbol(DX3ME1) //
define(DX3ME2,011E0040) //TextureVertexShader
Registersymbol(DX3ME2) //
define(DX3ME3,011E0080) //("../Dx11Demo_11/texture.vs")
Registersymbol(DX3ME3) //
define(DX3ME4,011E00C0)  //vs_5_0
Registersymbol(DX3ME4) //
define(DX3ME5,011E0100)//TextureVertexShader
Registersymbol(DX3ME5) //
define(DX3ME6,011E0140) ///("../Dx11Demo_11/texture.vs")
Registersymbol(DX3ME6) //
define(DX3ME7,011E0180) //vs_5_0
Registersymbol(DX3ME7) //
define(DX3ME8,011E01c0) //vs_5_0
Registersymbol(DX3ME8) //
////////////////////Path
define(PathMainX,011E0200) //main
Registersymbol(PathMainX) //
define(ddsPath,PathMainX+40) //../Dx11Demo_11/data/seafloor.dd
Registersymbol(ddsPath) //


 
[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>879</ID>
      <Description>"define(배열 리스트) 01304000~01404000 배열 저장소 //4바이트마다 더해지는 주소지 저장소"</Description>
      <LastState Activated="1"/>
      <Color>FF0000</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

//01304000~01404000 배열 저장소 //4바이트마다 더해지는 주소지 저장소

define(ValueList,01314000) //LgoinSwitch
Registersymbol(ValueList)//LgoinSwitch

//////////////////////////////팩토리 영역
define(factory,0132f000) //팩토리
Registersymbol(factory)
define(factory2,0132f004)
Registersymbol(factory2)

define(Errorsumalloc,01340000)//20 byte
Registersymbol(Errorsumalloc)

//많은 영역을 차지함(카피 메모리UTF-8에서 유니코드 변환 저장소
define(copyMemory,01370000) //복제해서 대입 할 문자열
Registersymbol(copyMemory)

define(basemeta,01390000) //기본문자열
Registersymbol(basemeta) //





[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>880</ID>
      <Description>"define(포인터 저장소) 01404000~01505000 포인터 저장소 //포인터 저장소,api"</Description>
      <LastState Activated="1"/>
      <Color>FF0000</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
//01404000~01505000 포인터 저장소 //포인터 저장소
////Main
define(baseP,01404000) //mainbaseP
Registersymbol(baseP)
define(factoryX,01404004)//시그너쳐 팩토리X인자생성
Registersymbol(factoryX)
define(Packtory,01404008)
Registersymbol(Packtory)

//////////////////Wdinwos//////////////////
define(hdc,01404008)//Windows HDC
Registersymbol(hdc)
define(Handle,0140400C)//Hadnle
Registersymbol(Handle)
//////////////////cmpsX//////////////////
define(cmpsX,01404090)//Hadnle
Registersymbol(cmpsX)

define(Pointer,01405000) //mainbaseP
Registersymbol(Pointer)

define(UIIPointer,Pointer+40)
Registersymbol(UIIPointer)
//PointerAPI/////////////////////////////
define(PointerAPI1,01406000)
Registersymbol(PointerAPI1)
define(PointerAPI2,PointerAPI1+4)
Registersymbol(PointerAPI2)
define(PointerAPI3,PointerAPI1+8)
Registersymbol(PointerAPI3)


[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>881</ID>
      <Description>"변수 저장소(define) 01506000~01607000 변수 저장소 :비교 문구,조건문,카운트,좌표,마우스 좌표"</Description>
      <LastState Activated="1"/>
      <Color>FF0000</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
//01506000~01607000 변수 저장소 :비교 문구,조건문,카운트,좌표
define(Msize,01506000)//변수 리스트 1000정도 여분이 필요함.
Registersymbol(Msize)
define(DebugCount,01507000)//디버그 카운트
Registersymbol(DebugCount)
 define(40Count,01507004) //40카운팅
Registersymbol(40Count) //
 define(4Count,01507008) //4카운팅
Registersymbol(4Count) //
 define(CountTimerjmp,0150700C) //TimerCount
Registersymbol(CountTimerjmp) //
 define(cmpsDebug,01507010) //TimerCount
Registersymbol(cmpsDebug) //
 define(MultX,01507014) //TimerCount
Registersymbol(MultX) //
 define(ErrorDebug,01507018) //TimerCount
Registersymbol(ErrorDebug) //

define(FloatX,01522300)
Registersymbol(FloatX)
define(FloatY,01522304)
Registersymbol(FloatY)





/////////////////많은양의 좌표 리스트

define(imageFloatD3D,01540000)
Registersymbol(imageFloatD3D)


define(IDENTY3,01541000)
Registersymbol(IDENTY3)
define(XMaskY,01542000)
Registersymbol(XMaskY)

 define(Woncode,01548000) //TimerCount
Registersymbol(Woncode) //
 define(MSCTUI,01549000) //TimerCount
Registersymbol(MSCTUI) //

 define(m_TextureShaderDBVMX,01549004) //TimerCount
Registersymbol(m_TextureShaderDBVMX) //
define(ShaderGates,m_TextureShaderDBVMX+4)
Registersymbol(ShaderGates)
define(ShaderDumys,m_TextureShaderDBVMX+8)
Registersymbol(ShaderDumys)

 define(CameraX,01559000) //TimerCount
Registersymbol(CameraX) //

 define(RxS3,0155A000) //TimerCount
Registersymbol(RxS3) //

 define(MiniTyX,0155B000) //TimerCount
Registersymbol(MiniTyX) //

define(Mouseallocx,01602c00)
Registersymbol(Mouseallocx)
define(Mouseallocy,01602c04)
Registersymbol(Mouseallocy)


define(ScrinX,01601000)
Registersymbol(ScrinX)
define(ScrinY,01601004)
Registersymbol(ScrinY)

define(charX,01602c08)
Registersymbol(charX)
define(charY,01602c0c)
Registersymbol(charY)

[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>882</ID>
      <Description>"문자열,사운드 식별자"</Description>
      <LastState Activated="1"/>
      <Color>0000FF</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

MiniTyX:
db 61 72 72 61 79 20 6E 65 77 20 6C 65 6E 67 74 68 00 00 00 00 64 69 40 00 C4 4C 40 00 F0 80 40 00 40 81 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 7F 00 00 80 7F 00 00 80 7F 00 00 80 7F 00 00 C0 7F 00 00 C0 7F 00 00 C0 7F 00 00 C0 7F FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 3F 00 00 00 3F 00 00 00 3F 00 00 00 3F 83 F9 22 3E 83 F9 22 3E 83 F9 22 3E 83 F9 22 3E FF FF FF 7F FF FF FF 7F FF FF FF 7F FF FF FF 7F 00 00 00 4B 00 00 00 4B 00 00 00 4B 00 00 00 4B DB 0F C9 40 DB 0F C9 40 DB 0F C9 40 DB 0F C9 40 00 00 00 80 00 00 00 80 00 00 00 80 00 00 00 80 DB 0F 49 40 DB 0F 49 40 DB 0F 49 40 DB 0F 49 40 DB 0F C9 3F DB 0F C9 3F DB 0F C9 3F DB 0F C9 3F 00 00 80 BF 00 00 80 BF 00 00 80 BF 00 00 80 BF 5B 36 CD B2 88 A8 2A BE 3C 37 08 3C C8 3E 42 B9 AB AA 2A BE 86 88 08 3C F1 0B 50 B9 8E B8 38 36 11 DD 8B B4 7E F6 FF BE 87 F5 29 3D DB 9F A6 BA 00 00 00 BF A3 AA 2A 3D AA 09 B6 BA C2 B4 CF 37 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 FF FF FF FF 00 00 80 3F 00 00 80 BF 00 00 80 BF 00 00 80 3F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 00 00 00 00 80 3F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 00 00 00 00 F2 AA 15 6F 08 D2 89 4E 9A B4 48 95 35 D3 4F 9C EC 66 71 7B C7 21 AE 44 B2 1A C9 AE 32 1A E3 69 4D 00 79 00 50 00 75 00 74 00 73 00 2E 00 64 00 6C 00 6C 00 00 00 00 00 47 65 74 4E 61 74 69 76 65 53 79 73 74 65 6D 49 6E 66 6F 00 6B 65 72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 00 45 00 72 00 72 00 6F 00 72 00 00 00 43 00 6F 00 75 00 6C 00 64 00 20 00 6E 00 6F 00 74 00 20 00 69 00 6E 00 69 00 74 00 69 00 61 00 6C 00 69 00 7A 00 65 00 20 00 44 00 69 00 72 00 65 00 63 00 74 00 33 00 44 00 2E 00 00 00 00 00 43 00 6F 00 75 00 6C 00 64 00 20 00 6E 00 6F 00 74 00 20 00 69 00 6E 00 69 00 74 00 69 00 61 00 6C 00 69 00 7A 00 65 00 20 00 74 00 68 00 65 00 20 00 54 00 65 00 78 00 74 00 75 00 72 00 65 00 20 00 73 00 68 00 61 00 64 00 65 00 72 00 20 00 6F 00 62 00 6A 00 65 00 63 00 74 00 2E 00 00 00 2E 00 2E 00 2F 00 44 00 78 00 31 00 31 00 44 00 65 00 6D 00 6F 00 5F 00 31 00 31 00 2F 00 64 00 61 00 74 00 61 00 2F 00 73 00 65 00 61 00 66 00 6C 00 6F 00 6F 00 72 00 2E 00 64 00 64 00 73 00 00 00 00 00 00 00 00 00 43 00 6F 00 75 00 6C 00 64 00 20 00 6E 00 6F 00 74 00 20 00 69 00 6E 00 69 00 74 00 69 00 61 00 6C 00 69 00 7A 00 65 00 20 00 74 00 68 00 65 00 20 00 62 00 69 00 74 00 6D 00 61 00 70 00 20 00 6F 00 62 00 6A 00 65 00 63 00 74 00 2E 00 00 00 44 00
RxS3:
db FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 3F 00 00 00 3F 00 00 00 3F 00 00 00 3F 83

CameraX:
db 00 00 80 3F 00 00 00 40 79 82 1A 40 00 00 C8 42 00 00 00 00 15 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 00 00 00 00 01 00 00 00 02 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 02 00 00 00 01 00 00 00 01 00 00 00 07 00 00 00 01 00 00 00 08 00 00 00 01 00 00 00 08 00 00 00 01 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 00 80 00 00 00 80 00 00 00 80 00 00 00 80 00 00 00 00 8F 80 E9 61 00 00 00 00 02 00 00 00 55 00 00 00 D4 69 00 00 D4 4F 00 00 00 00 00 00 8F 80 E9 61 00 00 00 00 0C 00 00 00 14 00 00 00 2C 6A 00 00 2C 50 00 00 00 00 00 00 8F 80 E9 61 00 00 00 00 0D 00 00 00 B4 02 00 00 40 6A 00 00 40 50 00 00 00 00 00 00 8F 80 E9 61 00 00 00 00 0E 00 00 00 00 00 00 00 00 00 00 00 00

CameraX-30:
db 72 00 6F 00 72 00 20 00 63 00 6F 00 6D 00 70 00 69 00 6C 00 69 00 6E 00 67 00 20 00 73 00 68 00 61 00 64 00 65 00 72 00 2E 00 00 00 35 FA 8E 3C 00 00 80 3F 00 00 00 40 79 82 1A 40 00 00 C8 42 00 00 00 00 15 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 00 00 00 00 01 00 00 00 02 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 02 00 00 00 01 00 00 00 01 00 00 00 07 00 00 00 01 00 00 00 08 00 00 00 01 00 00 00 08 00 00 00 01 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 00 80 00 00 00 80 00 00 00 80 00 00 00 80 00 00 00 00 8F 80 E9 61 00 00 00 00 02 00 00 00 55 00 00 00 D4 69 00 00 D4 4F 00 00 00 00 00 00 8F 80 E9 61 00 00 00 00 0C 00 00 00 14 00 00 00 2C 6A 00 00 2C 50 00 00 00 00 00 00 8F 80 E9 61 00 00 00 00 0D 00 00 00 B4 02 00 00 40 6A 00 00 40 50 00 00 00 00 00 00 8F 80 E9 61 00 00 00 00 0E 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 BC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 14 80 40 00 AC 69 40 00 04 00 00 00 70 61 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 BC 69 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 E4 80 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 40 80 40 00 94 68 40 00 00 00 00 00 00 00 00 00 01 00 00 00 A4 68 40 00 AC 68 40 00 00 00 00 00 40 80 40 00 00 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 40 00 00 00 94 68 40 00 00 00 00 00 00 00 00 00 00 00 00 00 24 80 40 00 DC
guiDx3ID2:
db F2 AA 15 6F 08 D2 89 4E 9A B4 48 95 35 D3 4F 9C EC 66 71 7B C7 21 AE 44 B2 1A C9 AE 32 1A E3 69 4D 00 79 00 50 00 75 00 74 00 73 00 2E 00 64 00 6C 00 6C 00 00 00 00 00 47 65 74 4E 61 74 69 76 65 53 79 73 74 65 6D 49 6E 66 6F 00 6B 65 72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 00 45 00 72 00 72 00 6F 00 72 00 00 00 43 00 6F 00 75 00 6C 00 64 00 20 00 6E 00 6F 00 74 00 20 00 69 00 6E 00 69 00 74 00 69 00 61 00 6C 00 69 00

guiDx3ID:
db EC 66 71 7B C7 21 AE 44 B2 1A C9 AE 32 1A E3 69 4D 00 79 00 50 00 75 00 74 00 73 00 2E 00 64 00 6C 00 6C 00 00 00 00 00 47 65 74 4E 61 74 69 76 65 53 79 73 74 65 6D 49 6E 66 6F 00 6B 65 72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 00 45 00 72 00 72 00 6F 00 72 00 00 00 43 00 6F 00 75 00 6C 00 64 00 20 00 6E 00 6F 00 74 00 20 00 69 00 6E 00 69 00 74 00 69 00 61 00 6C 00 69 00 7A 00 65 00 20 00 44 00 69 00 72 00 65 00 63 00 74 00 33 00 44 00 2E 00 00 00 00 00 43 00 6F 00 75 00 6C 00 64 00 20

Direct2DKEY:
db 4D 00 65 00 69 00 72 00 79 00 6F 00 00 00 00

factoryGUID:
db 47 22 15 06 50 6F 5A 46 92 45 11 8B FD 3B 60 07 00 00 00 00 00 00
UnicodeDirect2DX1:
db 64 00 78 00 32 00 5F 00 74 00 73 00 30 00 30 00 00 00 00 00
UnicodeDirect2DX2:
db 32 00 5F 00 74 00 73 00 30 00 30 00 00 00 00 00 00
UnicodeDirect2DX3:
db 74 00 73 00 30 00 30 00 00 00 00 00

mp3Type:
db A9 68 A8 56 D4 0A CE 11 B0 3A 00 20 AF 0B A7 70 00 00 00 00
mp3Type+20:
db B3 EB 36 E4 4F 52 CE 11 9F 53 00 20 AF 0B A7 70 00 00 00 00
mp3Type+40:
db B1 68 A8 56 D4 0A CE 11 B0 3A 00 20 AF 0B A7 70 00 00 00 00
mp3Type+60:
db B6 68 A8 56 D4 0A CE 11 B0 3A 00 20 AF 0B A7 70 00 00 00 00


charX:
dd #188

charY:
dd #301

basemeta:
db 'Logo' 00

basemeta+10:
db 'Label'

basemeta+20:
db 'CoreStory' 00

basemeta+30:
db 'button'

basemeta+40:
db 'CoreStoryClass' 00
basemeta+50:
db 'edit' 00
basemeta+60:
db 'Static' 00
basemeta+70:
db 'combobox' 00
basemeta+80:
db 73 'tatic' 00

/////////////////////////////////////////////////////로그인
basemeta+a0:
db '.\etc\logo\main.png' 00 00
basemeta+c0:
db '.\etc\logo\loginDIg.png' 00 00
basemeta+e0:
db '.\etc\logo\idfind.png' 00 00
basemeta+100:
db '.\etc\logo\okbox.png' 00 00
basemeta+120:
db '.\etc\logo\canser.png' 00 00
basemeta+140:
db '.\etc\logo\Cursor.png' 00 00
//////////////////////////////////////월드창
basemeta+160:
db '.\etc\World\WorldS1.png' 00 00
basemeta+180:
db '.\etc\World\WorldS2.png' 00 00
basemeta+1a0:
db '.\etc\World\WorldS3.png' 00 00
basemeta+1c0:
db '.\etc\World\WorldS4.png' 00 00
basemeta+1e0:
db '.\etc\World\WorldS5.png' 00 00
////////////////////////////메인 캐릭터 선택창
basemeta+200:
db '.\etc\CharS\ch1.png' 00 00
basemeta+220:
db '.\etc\CharS\ch2.png' 00 00
///////////
basemeta+240:
db '.\etc\CharS\ch3.png' 00 00
basemeta+260:
db '.\etc\CharS\ch4.png' 00 00
//캐릭터 커스텀 \etc\CHCustom
basemeta+280:
db '.\etc\wa1\body0.png' 00 00 //캐릭터 생성
basemeta+2A0:
db '.\etc\wa1\head.png' 00 00 //캐릭터 생성
basemeta+2C0:
db '.\etc\wa1\arm0.png' 00 00 //캐릭터 생성
basemeta+2E0:
db '.\etc\wa1\Face0.png' 00 00 //캐릭터 생성
basemeta+300:
db '.\etc\wa1\hair0.png' 00 00 //캐릭터 생성

/////////////////////
basemeta+320:
db '.\etc\wa\arm1.png' 00 00 //캐릭터 생성
basemeta+340:
db '.\etc\wa\arm2.png' 00 00 //캐릭터 생성
basemeta+360:
db '.\etc\wa\arm3.png' 00 00 //캐릭터 생성
basemeta+380:
db '.\etc\wa\arm4.png' 00 00 //캐릭터 생성
basemeta+3A0:
db '.\etc\wa\arm5.png' 00 00 //캐릭터 생성
/////////////////////////////////////////////////
basemeta+3C0:
db '.\etc\wa\head.png' 00 00 //캐릭터 생성

basemeta+1000:
db '.\etc\Sound\main.mp3' 00 00
basemeta+1020:
db 'KK찡그린얼굴' 00 00
basemeta+1040:
db 'KK구긴얼굴' 00 00
///////////////////머리
basemeta+1060:
db 'KK검은색빡빡머리' 00 00
basemeta+1080:
db 'KK갈색더벅머리' 00 00

basemeta+10A0:
db 'KK검은색토벤머리' 00 00
//////////////////////////////////////하얀 반팔 면티
basemeta+10C0:
db 'KK하얀반팔면티' 00 00
basemeta+10E0:
db 'KK하얀면나시' 00 00
basemeta+1100:
db 'KK회색반팔면티' 00 00
///////////////////반바지
basemeta+1100:
db 'KK파랑청반바지' 00 00
basemeta+1120:
db 'KK갈색면바지' 00 00
basemeta+1140:
db 'KK초록면바지' 00 00
////////////////////////////신발
basemeta+1160:
db 'KK가죽샌들' 00 00
basemeta+1180:
db 'KK빨간색고무장화' 00 00
basemeta+11A0:
db 'KK노란색고무장화' 00 00
/////////////////////////////검
basemeta+11C0:
db 'KK검' 00 00
basemeta+11E0:
db 'KK도끼' 00 00
basemeta+1200:
db 'KK몽둥이' 00 00
////////////////////////////////////////////////3끝

[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>883</ID>
      <Description>"4byte변수"</Description>
      <LastState Activated="1"/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
Msize://변환 활 문자열
dd #13000
Msize+4:
dd #2000

ScrinX:
dd #600
ScrinY:
dd #800

[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>884</ID>
      <Description>"diret"</Description>
      <LastState Activated="1"/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

label(Set1)
label(Set2)

diret:
push ecx
lea ecx,[esp+04]
sub ecx,eax
sbb eax,eax
not eax
and ecx,eax
mov eax,esp
and eax,FFFFF000 { -4096 }
Set2:
cmp ecx,eax
jb Set1//BeatriceServer.exe+12FF721
mov eax,ecx
pop ecx
xchg eax,esp
mov eax,[eax]
mov [esp],eax
repne ret
Set1:
sub eax,00001000 { 4096 }
test [eax],eax
jmp Set2//BeatriceServer.exe+12FF712


[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>885</ID>
      <Description>"diret"</Description>
      <LastState Activated="1"/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]


ErrorSum:
mov [Errorsumalloc+4],eax
mov [Errorsumalloc+8],ebx
mov [Errorsumalloc+c],ecx
mov [Errorsumalloc+10],edx
mov [Errorsumalloc+14],edi
mov [Errorsumalloc+18],esi
mov [Errorsumalloc+1c],esp
mov [Errorsumalloc+20],ebp
push #800000000
call sleep

[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>886</ID>
      <Description>"BrashList"</Description>
      <LastState Activated="1"/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]



BrashFloat1D0:
db 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 80 3F 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 00 00 22 08 CF 61 00 00 00 00 02 00 00 00 64 00 00 00 98 35 00 00 98 23 00 00 00 00 00 00 22 08 CF 61 00 00 00 00 0C 00 00 00 14 00 00 00 FC 35 00 00 FC 23 00 00 00 00 00 00 22 08 CF 61 00 00 00 00 0D 00 00 00 B4 02 00 00 10 36 00 00 10 24 00 00 00 00 00 00 22 08 CF 61 00 00 00 00 0E 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 BC 00 00 00
MetaIn2:
db 32 00 33 00 33 00 34 00 35 00 36 00 37 00 38 00 39 00 61 00 62 00 63 00 64 00 65 00 66 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
6CMeta:
db 6c 00 00 00 00

ChnerMenu:
db 4D 00 61 00 70 00 6C 00 65 00 4D 00 65 00 6D 00 65 00 2D 00 31 00 00 00 00 00 00 00 00 00
[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>887</ID>
      <Description>"IAT문자열 찍어내기"</Description>
      <LastState Activated="1"/>
      <Color>0000FF</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
objectsize:
//
apilist:
db 'CoInitialize'
dlllist:
db 'ole32.dll'

apilist+20:
db 'CoCreateInstance'
dlllist+20:
db 'combase.dll'

apilist+40:
db 'CoUninitialize'

dlllist+40:
db 'combase.dll'

apilist+60:
db 'malloc'

dlllist+60:
db 'ucrtbased.dll'

apilist+80:
db 'printf'

dlllist+80:
db 'msvcrt.dll'

apilist+A0:
db 'strlen'

dlllist+A0:
db 'ucrtbased.dll'

apilist+C0:
db 'MultiByteToWideChar'

dlllist+C0:
db 'kernel32.dll'

apilist+E0:
db 'WideCharToMultiByte'

dlllist+E0:
db 'kernel32.dll'

apilist+100:
db 'CreateThread'

dlllist+100:
db 'kernel32.dll'

apilist+120:
db 'CloseHandle'

dlllist+120:
db 'kernel32.dll'

apilist+140:
db 'BeginPaint'

dlllist+140:
db 'USER32.dll'

apilist+160:
db 'CreateCompatibleDC'

dlllist+160:
db 'GDI32.dll'

dlllist+180:
db 'USER32.dll' //

apilist+180:
db 'GetClientRect'

dlllist+1A0:
db 'ntdll.dll'

apilist+1A0:
db 'memset'

dlllist+1C0:
db 'kernel32.dll'

apilist+1C0:
db 'GetStartupInfoW'

dlllist+1E0:
db 'USER32.dll'

apilist+1E0:
db 'LoadIconA'


dlllist+200:
db 'USER32.dll'
apilist+200:
db 'DrawTextW'

dlllist+220:
db 'USER32.dll'
apilist+220:
db 'EndPaint'

dlllist+240:
db 'USER32.dll'
apilist+240:
db 'PostQuitMessage'

dlllist+260:
db 'ntdll.dll'
apilist+260:
db 'NtdllDefWindowProc_W'

dlllist+280:
db 'USER32.dll'
apilist+280:
db 'LoadIconW'

dlllist+2A0:
db 'USER32.dll'
apilist+2A0:
db 'LoadCursorW'

dlllist+2C0:
db 'GDI32.dll'
apilist+2C0:
db 'GetStockObject'

dlllist+2E0:
db 'USER32.dll'
apilist+2E0:
db 'RegisterClassW'

dlllist+300:
db 'USER32.dll'
apilist+300:
db 'CreateWindowExW'

dlllist+320:
db 'USER32.dll'
apilist+320:
db 'ShowWindow'

dlllist+340:
db 'USER32.dll'
apilist+340:
db 'UpdateWindow'

dlllist+360:
db 'USER32.dll'
apilist+360:
db 'GetMessageW'

dlllist+380:
db 'USER32.dll'
apilist+380:
db 'TranslateMessage'

dlllist+3A0:
db 'USER32.dll'
apilist+3A0:
db 'DispatchMessageW'

dlllist+3C0:
db 'USER32.dll'
apilist+3C0:
db 'SendMessageA'

dlllist+3E0:
db 'USER32.dll'
apilist+3E0:
db 'LoadImageW'


define(USER,dlllist+140)
Registersymbol(USER)

define(ntdlls,dlllist+180)
Registersymbol(ntdlls)

define(kerner,dlllist+C0)
Registersymbol(kerner)

[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>888</ID>
      <Description>"IAT Gate"</Description>
      <LastState Activated="1"/>
      <Color>0000FF</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
label(loop)
IATGate:
mov [ebp+8],0
mov [ebp+c],0
loop:
add [ebp+8],20
add [ebp+c],4
mov ecx,apilist-20 { ("CoInitialize") }
mov ebx,dlllist-20 { ("ole32.dll") }
mov edi,[ebp+8]
add ecx,edi
add ebx,edi
push ecx
push ebx
call dword ptr [GetModules] { -&gt;KERNEL32.GetModuleHandleA }
push eax
call dword ptr [GProc] { -&gt;KERNEL32.GetProcAddress }
mov edi,[ebp+c]
mov [IAT-4+edi],eax { (76F09BC0) }
mov edi,[ebp+8]
cmp [apilist+edi],0
jne loop
ret



[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>889</ID>
      <Description>"Pointer"</Description>
      <LastState Activated="1"/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
Pointer: //카피 메모리 -40 포인터 연산지 주소 배열
dd copyMemory+100
Pointer+8: //카피 메모리 -40 포인터 연산지 주소 배열
db 0A //printf

Pointer+38: //카피 메모리 -40 포인터 연산지 주소 배열
dd (float)1 //printf


//Pointer+c: //화면 on,off

Pointer+78:
dd ValueList


[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>890</ID>
      <Description>"사운드 =병렬처리"</Description>
      <LastState Activated="1"/>
      <Color>00FF00</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]



SoundX:
push ebp
mov ebp,esp
sub esp,000000FC { 252 }
push ebx
push esi
push edi
lea edi,[ebp-3C]
mov ecx,0000000F { 15 }
mov eax,CCCCCCCC { -858993460 }
repe stosd
mov [ebp-08],00000000 { 0 }
mov [ebp-14],00000000 { 0 }
mov [ebp-20],00000000 { 0 }
mov esi,esp
push 00 { 0 }
call [IAT] //CoInitialize
mov [ebp-2C],eax
mov esi,esp
lea eax,[ebp-08]
push eax
push mp3Type//Project5ffff.IID_IGraphBuilder { (1453877417) }
push 01 { 1 }
push 00 { 0 }
push mp3Type+20 { (-466162765) }
call [IAT+4] //CoCreateInstance

mov [ebp-2C],eax
mov esi,esp
lea eax,[ebp-14]
push eax
push mp3Type+40//Project5ffff.IID_IMediaControl { (1453877425) }
mov ecx,[ebp-08]
mov edx,[ecx]
mov eax,[ebp-08]
push eax
mov ecx,[edx]
call ecx

mov [ebp-2C],eax
mov esi,esp
lea eax,[ebp-20]
push eax
push mp3Type+60//00402000+40//00402000+60//Project5ffff.IID_IMediaEvent { (1453877430) }
mov ecx,[ebp-08]
mov edx,[ecx]
mov eax,[ebp-08]
push eax
mov ecx,[edx]
call ecx

mov [ebp-2C],eax
mov esi,esp
push 00 { 0 }
push copyMemory+2000{ ("C:\login.mp3") }
mov eax,[ebp-08]
mov ecx,[eax]
mov edx,[ebp-08]
push edx
mov eax,[ecx+34]
call eax

mov [ebp-2C],eax
mov eax,[ebp-14]
mov ecx,[eax]
mov esi,esp
mov edx,[ebp-14]
push edx
mov eax,[ecx+1C]
call eax

mov [ebp-2C],eax
mov esi,esp
lea eax,[ebp-38]
push eax
push -01 { 255 }
mov ecx,[ebp-20]
mov edx,[ecx]
mov eax,[ebp-20]
push eax
mov ecx,[edx+24]
call ecx

mov eax,[ebp-14]
mov ecx,[eax]
mov esi,esp
mov edx,[ebp-14]
push edx
mov eax,[ecx+08]
call eax

mov eax,[ebp-20]
mov ecx,[eax]
mov esi,esp
mov edx,[ebp-20]
push edx
mov eax,[ecx+08]
call eax

mov eax,[ebp-08]
mov ecx,[eax]
mov esi,esp
mov edx,[ebp-08]
push edx
mov eax,[ecx+08]
call eax
mov esi,esp
call [IAT+8] //dword ptr [Project5ffff._imp__CoUninitialize] { -&gt;combase.CoUninitialize }

xor eax,eax
push edx
mov ecx,ebp
push eax
mov edx,4 { (4) }

pop eax
pop edx
pop edi
pop esi
pop ebx
add esp,000000FC { 252 }

mov esp,ebp
pop ebp
ret


[DISABLE]
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>891</ID>
      <Description>"malloc24 = 24"</Description>
      <LastState Activated="1"/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
malloc24:
push #400
call [IAT+C]//ucrtbased.malloc
add esp,4
mov [ebp+24],eax //복제된 데이터가 저장될 주소
sub eax,#150
mov [ebp+20],eax //복제된 데이터가 저장될 주소
ret
[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>892</ID>
      <Description>"malloc28 =1000"</Description>
      <LastState Activated="1"/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
malloc28:
push #1000
call [IAT+C]
add esp,4
mov [ebp+28],eax //복제된 데이터가 저장될 주소
ret
[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>893</ID>
      <Description>"malloc4"</Description>
      <LastState Activated="1"/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
malloc4:
push #00401000
call [IAT+C]
add esp,4
mov [Pointer+40],eax //복제된 데이터가 저장될 주소

push #00401000 { 1024 } //size
push 00 { 0 }
push [Pointer+40] //setPointer
call ntdll.memset //- 8B 54 24 0C
//memset
add esp,0C { 12 }

ret
[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>894</ID>
      <Description>"병렬 쓰레드 = ecx"</Description>
      <LastState Activated="1"/>
      <Color>FF0000</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
Th:
push 0
push 0
push ecx
push ecx
push 0
push 0
call [IAT+20] //Thread
push eax
call [IAT+24]//kernel32.CloseHandle
ret

[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>895</ID>
      <Description>"멀티바이트 변환 logic"</Description>
      <LastState Activated="1"/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
MChapi://00501000
push [Msize]//
push copyMemory //빈공간에 로드할 address
push basemeta //기본 문자열
call [IAT+14]//ucrtbased.strlen //ucrtbasaeloasd
add esp,04
push [Msize] //size
push basemeta //기본 문자열
push 00
push 0000FDE9 //형식 CP_UTF8 의 형식임을 따른다.
call [IAT+18] //kernel32.MultiByteToWideChar
ret



 
 
[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>896</ID>
      <Description>"GraphicsClassX(main)"</Description>
      <LastState Activated="1"/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

//Dx11Demo_11.GraphicsClass::Initialize:
//jmp GraphicsClassX

PointerAPI1:
dd ucrtbase.aligned_malloc

label(NullPointer1)
label(NullPointer2)
label(ErrorPointerJNEX)
label(EndPointer1)
label(EndPointer2)
label(CreateBitmapSaveX2C)
label(Error07X)
GraphicsClassX:
push ebp
mov ebp,esp
sub esp,10 { 16 }
push ebx
push esi
push edi
//	// Direct3D 객체 생성
//	m_Direct3D = new D3DClass;
push 10 { 00000010 }
push 00000180 { 384 }

mov edi,ecx
//	// Direct3D 객체 생성
//	m_Direct3D = new D3DClass;
call ucrtbase.aligned_malloc
mov esi,eax
add esp,08 { 8 }
mov [ebp-04],esi //Getalloc
test esi,esi
je NullPointer1//Dx11Demo_11.GraphicsClass::Initialize+282

push 00000080 { 128 }
lea ecx,[esi+08]
mov byte ptr [esi],00 { 0 }
push 00 { 0 }
push ecx
mov [esi+04],00000000 { 0 }
call VCRUNTIME140.memset//Dx11Demo_11.memset { -&gt;-&gt;VCRUNTIME140.memset }
add esp,0C { 12 }
mov [esi+00000088],00000000 { 0 }
mov [esi+0000008C],00000000 { 0 }
mov [esi+00000090],00000000 { 0 }
mov [esi+00000094],00000000 { 0 }
mov [esi+00000098],00000000 { 0 }
mov [esi+0000009C],00000000 { 0 }
mov [esi+000000A0],00000000 { 0 }
mov [esi+000000A4],00000000 { 0 }
mov [esi+00000170],00000000 { 0 }
mov [edi],esi
test esi,esi
je NullPointer1//Dx11Demo_11.GraphicsClass::Initialize+288

/*
	// Direct3D 객체 초기화
	if(!m_Direct3D-&gt;Initialize(screenWidth, screenHeight, VSYNC_ENABLED, hwnd, FULL_SCREEN, SCREEN_DEPTH, SCREEN_NEAR))
00403679  mov         ebx,dword ptr [hwnd]
*/

mov ebx,[ebp+10]
sub esp,0C { 12 }
mov [esp+08],3DCCCCCD { 0.10 }
mov [esp+04],447A0000 { 1000.00 }
push ebx
push ecx
push [ebp+0C] //[screenHeight]
mov ecx,esi
push [ebp+08] // [screenWidth]
call D3DInitialize//Dx11Demo_11.D3DClass::Initialize//D3DInitialize//Dx11Demo_11.D3DClass::Initialize
test al,al
jne ErrorPointerJNEX//Dx11Demo_11.GraphicsClass::Initialize+F0
mov [ErrorDebug],8
pop edi
pop esi
xor al,al
pop ebx
mov esp,ebp
pop ebp
ret 000C { 12 }
ErrorPointerJNEX:
// m_Camera 객체 생성
//m_Camera = new CameraClass;
mov esi,[PointerAPI1]//aligned_malloc//apiX
push 10 { 00000010 }
push 60 { 96 }
call esi
mov ecx,eax
add esp,08 { 8 }
mov [ebp+10],ecx//[hwnd],ecx
test ecx,ecx
je EndPointer1//Dx11Demo_11.GraphicsClass::Initialize+270
xorps xmm1,xmm1
mov [ebp-08],00000000 { 0 }
mov eax,[ebp-08]
xorps xmm0,xmm0
unpcklps xmm0,xmm1
movq [ecx],xmm0
mov [ecx+08],eax
unpcklps xmm1,xmm1
movq [ecx+0C],xmm1
mov [ebp-08],00000000 { 0 }
mov eax,[ebp-08]
mov [ecx+14],eax
mov [edi+04],ecx
	// m_TextureShader 객체 생성
	//m_TextureShader = new TextureShaderClass;
push 10 { 00000010 }
push 14 { 00000014 }
/*
	// 카메라 포지션 설정
	m_Camera-&gt;SetPosition(0.0f, 0.0f, -6.0f);
*/
mov [ecx],00000000 { 0 }
mov [ecx+04],00000000 { 0 }
mov [ecx+08],C0C00000 { -6.00 }
call esi

mov ecx,eax
add esp,08 { 8 }
mov [ebp+10],ecx
test ecx,ecx
je EndPointer2//Dx11Demo_11.GraphicsClass::Initialize+25E
mov [ecx],00000000 { 0 }
sub esp,08 { 8 }
/*
	// m_TextureShader 객체 초기화
	if (!m_TextureShader-&gt;Initialize(m_Direct3D-&gt;GetDevice(), hwnd))
*/

	// m_TextureShader 객체 생성
	//m_TextureShader = new TextureShaderClass;

mov [ecx+04],00000000 { 0 }
mov [ecx+08],00000000 { 0 }
mov [ecx+0C],00000000 { 0 }
mov [ecx+10],00000000 { 0 }
// m_TextureShader 객체 초기화
//	if (!m_TextureShader-&gt;Initialize(m_Direct3D-&gt;GetDevice(), hwnd))
mov eax,[edi]
mov eax,[edi+18]
mov [m_TextureShaderDBVMX],eax
mov eax,[edi]
push ebx
	// m_TextureShader 객체 생성
//	m_TextureShader = new TextureShaderClass;

// m_TextureShader 객체 초기화
//	if (!m_TextureShader-&gt;Initialize(m_Direct3D-&gt;GetDevice(), hwnd))
mov [edi+08],ecx //save
push [eax+0000008C]
call TextureShaderClassDBVM//Dx11Demo_11.TextureShaderClass::InitializeShader
test al,al
jne CreateBitmapSaveX2C//Dx11Demo_11.GraphicsClass::Initialize+1C0
mov [ErrorDebug],7
pop edi
pop esi
xor al,al
pop ebx
mov esp,ebp
pop ebp
ret 000C { 12 }
CreateBitmapSaveX2C:
	// 비트맵 객체 생성
//	m_Bitmap = new BitmapClass;
push 2C { 0000002C }
call operX//"Dx11Demo_11.operator new"
mov ecx,eax
sub esp,08 { 8 }
mov [ebp+10],ecx
push [ebp+0C]//[screenHeight]
	// 비트맵 객체 생성
//	m_Bitmap = new BitmapClass;
mov [ecx],00000000 { 0 }
push [ebp+08]//004037A8  push        dword ptr [screenWidth]

mov [ecx+04],00000000 { 0 }
mov [ecx+08],00000000 { 0 }
mov [ecx+0C],00000000 { 0 }
mov [ecx+10],00000000 { 0 }
mov [ecx+14],00000000 { 0 }
mov [ecx+18],00000000 { 0 }
mov [ecx+1C],00000000 { 0 }
mov [ecx+20],00000000 { 0 }
mov [ecx+24],00000000 { 0 }
mov [ecx+28],00000000 { 0 }
mov eax,[edi]
mov [edi+0C],ecx
push [eax+0000008C]
call DXBitmapClassInitialize //Dx11Demo_11.BitmapClass::Initialize
push #80000000
call sleep
test al,al
jne Error07X//Dx11Demo_11.GraphicsClass::Initialize+253
mov [ErrorDebug],6
pop edi
pop esi
xor al,al
pop ebx
mov esp,ebp
pop ebp
ret 000C { 12 }
Error07X:
pop edi
pop esi
mov al,01 { 1 }
pop ebx
mov esp,ebp
pop ebp
ret 000C { 12 }
EndPointer2:
mov [edi+08],00000000 { 0 }
xor al,al
pop edi
pop esi
pop ebx
mov esp,ebp
pop ebp
ret 000C { 12 }
EndPointer1:
mov [edi+04],00000000 { 0 }
xor al,al
pop edi
pop esi
pop ebx
mov esp,ebp
pop ebp
ret 000C { 12 }
NullPointer1:
mov [edi],00000000 { 0 }
NullPointer2:
pop edi
pop esi
xor al,al
pop ebx
mov esp,ebp
pop ebp
ret 000C { 12 }



label(goto11)
label(goto12)
label(goto13)
operX:
push ebp
mov ebp,esp
jmp goto11//"WindowsProjeddct5.operator new"+12 { -&gt;WindowsProjeddct5.operator new+12 }
goto13:
push [ebp+08]
call ucrtbase.callnewh//WindowsProjeddct5._callnewh { -&gt;-&gt;ucrtbase.callnewh }
pop ecx
test eax,eax
je goto12//"WindowsProjeddct5.operator new"+21 { -&gt;WindowsProjeddct5.operator new+21 }
goto11:
push [ebp+08]
call ucrtbase.malloc //WindowsProjeddct5.malloc { -&gt;-&gt;ucrtbase.malloc }
pop ecx
test eax,eax
je goto13//"WindowsProjeddct5.operator new"+5 { -&gt;WindowsProjeddct5.operator new+5 }
pop ebp
ret
goto12:
ret
//cmp dword ptr [ebp+08],-01 { 255 }
//je WindowsProjeddct5.__scrt_throw_std_bad_array_new_length
//jmp WindowsProjeddct5.__scrt_throw_std_bad_alloc


label(7fffx)
label(leaesi)
label(7fffex2)
label(lea23x)
label(leaACDobule)
label(scrtX)
label(NullPointerX)
label(addebpC)
label(xorgateX)
label(returnd)
label(DeleateX)
label(returnDi)
MainMetaX:
push ebp
mov ebp,esp
push ecx
mov eax,[ebp+0C]
push ebx
push esi
push edi
mov edi,ecx
mov ecx,[edi+14]
mov [ebp-04],ecx
cmp eax,ecx
ja 7fffx//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+45 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+45 }
mov ebx,edi
cmp ecx,08 { 8 }
jb leaesi//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+1F { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+1F }
mov ebx,[edi]
lea esi,[eax+eax]
leaesi:
mov [edi+10],eax
push esi
push KEYSave//WindowsProjeddct5.exe+3278 { ("My Test Text!!") }
push ebx
call VCRUNTIME140.memcpy
add esp,0C { 12 }
xor eax,eax
mov [esi+ebx],ax
mov eax,edi
pop edi
pop esi
pop ebx
mov esp,ebp
pop ebp
ret 0008 { 8 }
7fffx:
mov esi,eax
or esi,07 { 7 }
cmp esi,7FFFFFFE { 2147483646 }
jna 7fffex2//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+69 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+69 }
mov esi,7FFFFFFE { 2147483646 }
mov eax,FFFFFFFE { -2 }
jmp lea23x//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+A3 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+A3 }
7fffex2:
mov edx,ecx
mov eax,7FFFFFFE { 2147483646 }
shr edx,1
sub eax,edx
cmp ecx,eax
jna leaACDobule//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+84 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+84 }
mov esi,7FFFFFFE { 2147483646 }
mov eax,FFFFFFFE { -2 }
jmp lea23x//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+A3 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+A3 }
leaACDobule:
lea eax,[edx+ecx]
cmp esi,eax
cmovb esi,eax
lea eax,[esi+01]
cmp eax,7FFFFFFF { 2147483647 }
ja scrtX//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+146 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+146 }
add eax,eax
cmp eax,00001000 { 4096 }
jb NullPointerX//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+CA { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+CA }
lea23x:
lea ecx,[eax+23]
cmp ecx,eax
jbe scrtX//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+146 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+146 }
push ecx
call operX//"WindowsProjeddct5.operator new"
add esp,04 { 4 }
test eax,eax
je ucrtbase.invalid_parameter_noinfo_noreturn //7000000상위 api "WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+140 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+140 }
lea ebx,[eax+23]
and ebx,-20 { 224 }
mov [ebx-04],eax
jmp addebpC//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+DD { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+DD }
NullPointerX:
test eax,eax
je xorgateX//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+DB { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+DB }
push eax
call operX//"WindowsProjeddct5.operator new"
add esp,04 { 4 }
mov ebx,eax
jmp addebpC//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+DD { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+DD }
xorgateX:
xor ebx,ebx
addebpC:
mov eax,[ebp+0C]
mov [edi+14],esi
mov [edi+10],eax
lea esi,[eax+eax]
push esi
push KEYSave//WindowsProjeddct5.exe+3278 { ("My Test Text!!") }
push ebx
call VCRUNTIME140.memcpy
xor eax,eax
add esp,0C { 12 }
mov [esi+ebx],ax
mov eax,[ebp-04]
cmp eax,08 { 8 }
jb returnd//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+133 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+133 }
lea ecx,[eax*2+00000002]
mov eax,[edi]
cmp ecx,00001000 { 4096 }
jb DeleateX//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+129 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+129 }
mov edx,[eax-04]
add ecx,23 { 35 }
sub eax,edx
add eax,-04 { 252 }
cmp eax,1F { 31 }
ja returnDi//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+140 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+140 }
mov eax,edx
DeleateX:
push ecx
push eax
call ucrtbase.free//"WindowsProjeddct5.operator delete"
add esp,08 { 8 }
returnd:
mov [edi],ebx
mov eax,edi
pop edi
pop esi
pop ebx
mov esp,ebp
pop ebp
ret 0008 { 8 }
returnDi:
call ucrtbase.invalid_parameter_noinfo_noreturn
scrtX:
//call WindowsProjeddct5.__scrt_throw_std_bad_array_new_length
//call WindowsProjeddct5.std::_Xlen_string
int 3
int 3
int 3
int 3






[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>897</ID>
          <Description>"GraphicsClassX::D3DInitialize"</Description>
          <LastState Activated="1"/>
          <Color>000080</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]

guiDx3ID:
db EC 66 71 7B C7 21 AE 44 B2 1A C9 AE 32 1A E3 69 4D 00 79 00 50 00 75 00 74 00 73 00 2E 00 64 00 6C 00 6C 00 00 00 00 00 47 65 74 4E 61 74 69 76 65 53 79 73 74 65 6D 49 6E 66 6F 00 6B 65 72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 00 45 00 72 00 72 00 6F 00 72 00 00 00 43 00 6F 00 75 00 6C 00 64 00 20 00 6E 00 6F 00 74 00 20 00 69 00 6E 00 69 00 74 00 69 00 61 00 6C 00 69 00 7A 00 65 00 20 00 44 00 69 00 72 00 65 00 63 00 74 00 33 00 44 00 2E 00 00 00 00 00 43 00 6F 00 75 00 6C 00 64 00 20
guiDx3ID2:
db F2 AA 15 6F 08 D2 89 4E 9A B4 48 95 35 D3 4F 9C EC 66 71 7B C7 21 AE 44 B2 1A C9 AE 32 1A E3 69 4D 00 79 00 50 00 75 00 74 00 73 00 2E 00 64 00 6C 00 6C 00 00 00 00 00 47 65 74 4E 61 74 69 76 65 53 79 73 74 65 6D 49 6E 66 6F 00 6B 65 72 6E 65 6C 33 32 2E 64 6C 6C 00 00 00 00 45 00 72 00 72 00 6F 00 72 00 00 00 43 00 6F 00 75 00 6C 00 64 00 20 00 6E 00 6F 00 74 00 20 00 69 00 6E 00 69 00 74 00 69 00 61 00 6C 00 69 00
woncode-80:
db 4F 4F 52 44 00 00 00 00 45 00 72 00 72 00 6F 00 72 00 20 00 63 00 6F 00 6D 00 70 00 69 00 6C 00 69 00 6E 00 67 00 20 00 73 00 68 00 61 00 64 00 65 00 72 00 2E 00 00 00 FD AD 80 3C 35 FA 8E 3C 00 00 80 3F 00 00 00 40 79 82 1A 40 00 00 C8 42 00 00 B4 43 00 00 00 00 00 00 00 00 00 00 00 00 15 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 00 00 00 00 01 00 00 00 02 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 02 00 00 00 01 00 00 00 01 00 00 00 07 00 00 00 01 00 00 00 08 00 00 00 01 00 00 00 08 00 00 00 01 00 00 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 00 80 00 00 00 80 00 00 00 80 00 00 00 80 00 00 00 00 F6 D3 D9 61 00 00 00 00 02 00 00 00 55 00 00 00 D4 69 00 00 D4 4F 00 00 00 00 00 00 F6 D3 D9 61 00 00 00 00 0C 00 00 00 14 00 00 00 2C 6A 00 00 2C 50 00 00 00 00 00 00 F6 D3 D9 61 00 00 00 00 0D 00 00 00 B4 02 00 00 40 6A 00 00 40 50 00 00 00 00 00 00 F6 D3 D9 61 00 00 00 00 0E 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 BC 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 14 80 40 00 AC 69 40 00 04 00 00 00 70 61 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 BC 69 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 E4 80 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 40 80 40 00 94 68 40 00 00 00 00 00 00 00 00 00 01 00 00 00 A4 68 40 00 AC 68 40 00 00 00 00 00 40 80 40 00 00 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 40 00 00 00 94 68 40 00 00 00 00 00 00 00 00 00 00 00 00 00 24 80 40 00 DC 68 40 00 00 00 00 00 00 00 00 00 02 00 00 00 EC 68 40 00 F8 68 40 00 AC 68 40 00 00 00 00 00 24 80 40 00 01 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 40 00 00 00 DC 68 40 00 00 00 00 00 00 00 00 00 00 00 00 00 5C 80 40 00 28 69 40 00 00 00 00 00 00 00 00 00 03 00 00 00 38 69 40 00 48 69 40 00 F8 68 40 00 AC 68 40 00 00 00 00 00 5C 80 40 00 02 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 40 00 00 00 28 69 40 00 00 00 00 00 00 00 00 00 00 00 00 00 84 80 40 00 78 69 40 00 00 00 00 00 00 00 00 00 01 00 00 00 88 69 40 00 90 69 40 00 00 00 00 00 84 80 40 00 00 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 40 00 00 00 78 69 40 00 D5 4C 00 00 8D 51 00 00 AD 51 00 00 B9 51 00 00 18 00 00 00 00 80 00 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 52 53 44 53 24 7F 19 0B 0F 96 95 44 A5 BE 34 C7 74 E5 1B CB 06 00 00 00 43 3A 5C 55 73 65 72 73 5C 6E 6E 69 6E 6E 5C 44 6F 77 6E 6C 6F 61 64 73 5C 44 78 31 31 44 65 6D 6F 5F 31 31 5C 52 65 6C 65 61 73 65 5C 44 78 31 31 44 65 6D 6F 5F 31 31 2E 70 64 62 00 00 00 00 00 00 00 00 35 00 00 00 2A 00 00 00 00 00 00 00 2A 00 00 00 47 43 54 4C 00 10 00 00 80 41 00 00 2E 74 65 78 74 24 6D 6E 00 00 00 00 80 51 00 00 56 00 00 00 2E 74 65 78 74 24 78 00 00 60 00 00 70 01 00 00 2E 69 64 61 74 61 24 35 00 00 00 00 70 61 00 00 04 00 00 00 2E 30 30 63 66 67 00 00 74 61 00 00 04 00 00 00 2E 43 52 54 24 58 43 41 00 00 00 00 78 61 00 00 04 00 00 00 2E 43 52 54 24 58 43 41 41 00 00 00 7C 61 00 00 04 00 00 00 2E 43 52 54 24 58 43 5A 00 00 00 00 80 61 00 00 04 00 00 00 2E 43 52 54 24 58 49 41 00 00 00 00 84 61 00 00 04 00 00 00 2E 43 52 54 24 58 49 41 41 00 00 00 88 61 00 00 04 00 00 00 2E 43 52 54 24 58 49 41 43 00 00 00 8C 61 00 00 04 00 00 00 2E 43 52 54 24 58 49 5A 00 00 00 00 90 61 00 00 04 00 00 00 2E 43 52 54 24 58 50 41 00 00 00 00 94 61 00 00 04 00 00 00 2E 43 52 54 24 58 50 5A 00 00 00 00 98 61 00 00 04 00 00 00 2E 43 52 54 24 58 54 41 00 00 00 00 9C 61 00 00 04 00 00 00 2E 43 52 54 24 58 54 5A 00 00 00 00 A0 61 00 00 E0 06 00 00 2E 72 64 61 74 61 00 00 80 68 00 00 2C 01 00 00 2E 72 64 61 74 61 24 72 00 00 00 00 AC 69 00 00 10 00 00 00 2E 72 64 61 74 61 24 73 78 64 61 74 61 00 00 00 BC 69 00 00 18 00 00 00 2E 72 64 61 74 61 24 76 6F 6C 74 6D 64 00 00 00 D4 69 00 00 20 03 00 00 2E 72 64 61 74 61 24 7A 7A 7A 64 62 67 00 00 00 F4 6C 00 00 04 00 00 00 2E 72 74 63 24 49 41 41 00 00 00 00 F8 6C 00 00 04 00 00 00 2E 72 74 63 24 49 5A 5A 00 00 00 00 FC 6C 00 00 04 00 00 00 2E 72 74 63 24 54 41 41 00 00 00 00 00 6D 00 00 08 00 00 00 2E 72 74 63 24 54 5A 5A 00 00 00 00 08 6D 00 00 7C 01 00 00 2E 78 64 61 74 61 24 78 00 00 00 00 84 6E 00 00 04 01 00 00 2E 69 64 61 74 61 24 32 00 00 00 00 88 6F 00 00 14 00 00 00 2E 69 64 61 74 61 24 33 00 00 00 00 9C 6F 00 00 70 01 00 00 2E 69 64 61 74 61 24 34 00 00 00 00 0C 71 00 00 14 07 00 00 2E 69 64 61 74 61 24 36 00 00 00 00 00 80 00 00 24 00 00 00 2E 64 61 74 61 00 00 00 24 80 00 00 60 00 00 00 2E 64 61 74 61 24 72 00 84 80 00 00 1C 00 00 00 2E 64 61 74 61 24 72 73 00 00 00 00 A0 80 00 00 80 03 00 00 2E 62 73 73 00 00 00 00 00 90 00 00 60 00 00 00 2E 72 73 72 63 24 30 31 00 00 00 00 60 90 00 00 80 01 00 00 2E 72 73 72 63 24 30 32 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 22 05 93 19 01 00 00 00 2C 6D 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 FF FF FF FF 80 51 40 00 22 05 93 19 01 00 00 00 58 6D 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 FF FF FF FF A0 51 40 00 FE FF FF FF 00 00 00 00 CC FF FF FF 00 00 00 00 FE FF FF FF ED 44 40 00 01 45 40 00 00 00 00 00 E9 45 40 00 00 00 00 00 8C 6D 40 00 02 00 00 00 98 6D 40 00 B4 6D 40 00 10 00 00 00 24 80 40 00 00 00 00 00 FF FF FF FF 00 00 00 00 0C 00 00 00 57 45 40 00 00 00 00 00 40 80 40 00 00 00 00 00 FF FF FF FF 00 00 00 00 0C 00 00 00 BD 45 40 00 00 00 00 00 E9 45 40 00 00 00 00 00 E0 6D 40 00 03 00 00 00 F0 6D 40 00 98 6D 40 00 B4 6D 40 00 00 00 00 00 5C 80 40 00 00 00 00 00 FF FF FF FF 00 00 00 00 0C 00 00 00 8A 45 40 00 40 00 00 00 00 00 00 00 00 00 00 00 A6 46 40 00 FF FF FF FF 00 00 00 00 FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 0C 6E 40 00 22 05 93 19 02 00 00 00 1C 6E 40 00 01 00 00 00 2C 6E 40 00 00 00 00 00 00 00 00 00 00 00 00 00 05 00 00 00 00 00 00 00 FE FF FF FF 00 00 00 00 D8 FF FF FF 00 00 00 00 FE FF FF FF 5E 48 40 00 71 48 40 00 AC 6F 00 00 00 00 00 00 00 00 00 00 C4 71 00 00 10 60 00 00 08 70 00 00 00 00 00 00 00 00 00 00 E4 72 00 00 6C 60 00 00 A4 6F 00 00 00 00 00 00 00 00 00 00 02 73 00 00 08 60 00 00 FC 70 00 00 00 00 00 00 00 00 00 00 2C 73 00 00 60 61 00 00 04 71 00 00 00 00 00 00 00 00 00 00 4A 73 00 00 68 61 00 00 9C 6F 00 00 00 00 00 00 00 00 00 00 6A 73 00 00 00 60 00 00 4C 70 00 00 00 00 00 00 00 00 00 00 34 74 00 00 B0 60 00 00 74 70 00 00 00 00 00 00 00 00 00 00 36 76 00 00 D8 60 00 00 7C 70 00 00 00 00 00 00 00 00 00 00 58 76 00 00 E0 60 00 00 A8 70 00 00 00 00 00 00 00 00 00 00 78 76 00 00 0C 61 00 00 A0 70 00 00 00 00 00 00 00 00 00 00 9A 76 00 00 04 61 00 00 F0 70 00 00 00 00 00 00 00 00 00 00 BA 76 00 00 54 61 00 00 98 70 00 00 00 00 00 00 00 00 00 00 DA 76 00 00 FC 60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 54 73 00 00 00 00 00 00 F0 72 00 00 00 00 00 00 58 71 00 00 64 71 00 00 74 71 00 00 86 71 00 00 9A 71 00 00 AE 71 00 00 16 77 00 00 2C 77 00 00 38 71 00 00 5C 77 00 00 72 77 00 00 86 77 00 00 A2 77 00 00 28 71 00 00 1A 71 00 00 C0 77 00 00 D2 77 00 00 EE 77 00 00 02 78 00 00 42 77 00 00 0C 71 00 00 FC 76 00 00 00 00 00 00 D2 72 00 00 AE 72 00 00 A2 72 00 00 8C 72 00 00 7E 72 00 00 6C 72 00 00 58 72 00 00 44 72 00 00 36 72 00 00 BE 72 00 00 D2 71 00 00 E0 71 00 00 F0 71 00 00 18 72 00 00 04 72 00 00 2A 72 00 00 00 00 00 00 10 74 00 00 1A 74 00 00 F2 73 00 00 DC 73 00 00 AC 73 00 00 16 78 00 00 94 73 00 00 7E 73 00 00 C6 73 00 00 00 00 00 00 46 74 00 00 00 00 00 00 76 74 00 00 82 74 00 00 AC 75 00 00 54 74 00 00 64 74 00 00 CC 75 00 00 00 00 00 00 96 75 00 00 00 00 00 00 AE 74 00 00 00 00 00 00 C2 74 00 00 5E 75 00 00 D4 75 00 00 F0 75 00 00 0C 76 00 00 54 75 00 00 1A 76 00 00 2A 76 00 00 DA 74 00 00 FA 74 00 00 3E 75 00 00 68 75 00 00 1C 75 00 00 36 75 00 00 9E 74 00 00 8C 74 00 00 28 75 00 00 00 00 00 00 BC 75 00 00 46 75 00 00 00 00 00 00 0C 73 00 00 00 00 00 00 36 73 00 00 00 00 00 00 89 00 43 6C 6F 73 65 48 61 6E 64 6C 65 00 CE 00 43 72 65 61 74 65 46 69 6C 65 57 00 64 02 47 65 74 4C 61 73 74 45 72 72 6F 72 00 00 4B 02 47 65 74 46 69 6C 65 49 6E 66 6F 72 6D 61 74 69 6F 6E 42 79 48 61 6E 64 6C 65 45 78 00 00 75 04 52 65 61 64 46 69 6C 65 00 00 C8 03 4C 6F 61 64 4C 69 62 72 61 72 79 57 00 00 B1 02 47 65 74 50 72 6F
imageFloatD3D: //231
db 79 82 1A 40 00 00 C8 42 00 00 B4 43 00 00 00 00 00 00 00 00 00 00 00 00 15 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 00 00 00 00 01 00 00 00 02 00 00 00 01 00 00 00 01
DBVMR3:
db 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 00 00 00 00 80 3F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 00 00 00 00 F2 AA 15 6F 08 D2 89 4E 9A B4 48 95 35 D3 4F 9C EC 66 71 7B C7 21 AE 44
XMaskY:
db 00 00 00 00 FF FF FF FF 00 00 00 00 00 00 00 00 F2 AA 15 6F 08 D2 89 4E 9A B4 48 95 35 D3 4F 9C EC 66 71 7B C7 21 AE 44 B2 1A C9 AE 32 1A E3 69 4D 00 79 00 50 00 75 00 74 00 73 00 2E 00 64 00 6C 00 6C 00 00 00
IDENTY3://많은양을 차지함
db 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 00 00 00 00 80 3F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 00 00 00 00 F2 AA 15 6F 08 D2 89 4E 9A B4 48 95 35 D3 4F 9C EC 66 71 7B C7 21 AE 44 B2 1A C9 AE 32 1A E3 69 4D 00 79 00 50


D3DInitialize:
label(ErrorsX)
label(returnfalseX)
label(goto3)
label(goto4)
label(elseX)
label(goto6)
/*
bool D3DClass::Initialize(int screenWidth, int screenHeight, bool vsync, HWND hwnd, bool fullscreen,
	float screenDepth, float screenNear)
{
*/

push ebp
mov ebp,esp
and esp,-10 { 240 }
sub esp,00000298 { 664 }
push esi
push edi
mov esi,ecx
/*
	// 수직동기화 상태를 저장합니다
	m_vsync_enabled = vsync;

	// DirectX 그래픽 인터페이스 팩토리를 생성합니다
	IDXGIFactory* factory = nullptr;
*/
mov [esp+1C],00000000 { 0 }
lea eax,[esp+1C]
mov [esp+44],esi
push eax
push guiDx3ID //{ (236) }
mov byte ptr [esi],01 { 1 }
call dxgi.CreateDXGIFactory
test eax,eax
js ErrorsX //Dx11Demo_11.D3DClass::Initialize+76E
/*
	{
		return false;
	}

	// 팩토리 객체를 사용하여 첫번째 그래픽 카드 인터페이스 어뎁터를 생성합니다
	IDXGIAdapter* adapter = nullptr;
	if (FAILED(factory-&gt;EnumAdapters(0, &amp;adapter)))
*/
mov eax,[esp+1C]
lea edx,[esp+14]
push edx//임의의 주소 생성
mov [esp+18],00000000 { 0 }
push 00 { 0 }
mov ecx,[eax]//포인터주소
push eax
call dword ptr [ecx+1C]
test eax,eax
js ErrorsX//Dx11Demo_11.D3DClass::Initialize+76E
/*
// 출력(모니터)에 대한 첫번째 어뎁터를 지정합니다.
	IDXGIOutput* adapterOutput = nullptr;
	if (FAILED(adapter-&gt;EnumOutputs(0, &amp;adapterOutput)))
    */
mov eax,[esp+14]
lea edx,[esp+10]
push edx
mov [esp+14],00000000 { 0 }
push 00 { 0 }
mov ecx,[eax]
push eax
call dword ptr [ecx+1C]
test eax,eax
js ErrorsX//Dx11Demo_11.D3DClass::Initialize+76E
/*
// 출력 (모니터)에 대한 DXGI_FORMAT_R8G8B8A8_UNORM 표시 형식에 맞는 모드 수를 가져옵니다
	unsigned int numModes = 0;
	if (FAILED(adapterOutput-&gt;GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &amp;numModes, NULL)))
    */
mov eax,[esp+10]
lea edx,[esp+18]
push 00 { 0 }
push edx
push 01 { 1 }
mov [esp+24],00000000 { 0 }
mov ecx,[eax]
push 1C { 28 }
push eax
call dword ptr [ecx+20]
test eax,eax
js ErrorsX//Dx11Demo_11.D3DClass::Initialize+76E
/*
	// 가능한 모든 모니터와 그래픽카드 조합을 저장할 리스트를 생성합니다
	DXGI_MODE_DESC* displayModeList = new DXGI_MODE_DESC[numModes];
*/
mov eax,[esp+18]
xor ecx,ecx
mov edx,0000001C { 28 }
mul edx
seto cl
neg ecx
or ecx,eax
push ecx
call operX//"Dx11Demo_11.operator new[]"//////////////////////////

/*
// 이제 디스플레이 모드에 대한 리스트를 채웁니다
	if (FAILED(adapterOutput-&gt;GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &amp;numModes, displayModeList)))

*/

mov ecx,[esp+14]
add esp,04 { 4 }
mov [esp+24],eax
mov edx,[ecx]
push eax
lea eax,[esp+1C]
push eax
push 01 { 1 }
push 1C { 28 }
push ecx
call dword ptr [edx+20]
test eax,eax
js ErrorsX//Dx11Demo_11.D3DClass::Initialize+76E

/*
	unsigned int denominator = 0;
	for (unsigned int i = 0; i&lt;numModes; i++)
*/


/*
// 이제 모든 디스플레이 모드에 대해 화면 너비/높이에 맞는 디스플레이 모드를 찾습니다.
	// 적합한 것을 찾으면 모니터의 새로고침 비율의 분모와 분자 값을 저장합니다.
	unsigned int numerator = 0;
*/
mov ecx,[esp+18]
mov edi,[ebp+0C]
mov [esp+28],00000000 { 0 }
mov [esp+2C],00000000 { 0 }
test ecx,ecx
je returnfalseX//Dx11Demo_11.D3DClass::Initialize+123 114lea
mov eax,[esp+24]
mov edx,[ebp+08]
add eax,08 { 8 }
goto4:


/*if (displayModeList[i].Width == (unsigned int)screenWidth) */
cmp [eax-08],edx
jne goto3//Dx11Demo_11.D3DClass::Initialize+117 add eax1c
/*if (displayModeList[i].Height == (unsigned int)screenHeight) */
cmp [eax-04],edi
jne goto3//Dx11Demo_11.D3DClass::Initialize+117
/*numerator = displayModeList[i].RefreshRate.Numerator;*/
mov esi,[eax]
mov [esp+28],esi
/*denominator = displayModeList[i].RefreshRate.Denominator;*/
mov esi,[eax+04]
mov [esp+2C],esi
goto3:
/*for (unsigned int i = 0; i&lt;numModes; i++)*/
add eax,1C { 28 }
sub ecx,01 { 1 }
jne goto4//cmps Dx11Demo_11.D3DClass::Initialize+100
mov esi,[esp+44]
returnfalseX:

/*
// 비디오카드의 구조체를 얻습니다
	DXGI_ADAPTER_DESC adapterDesc;
	if (FAILED(adapter-&gt;GetDesc(&amp;adapterDesc)))
*/

mov eax,[esp+14]
lea edx,[esp+00000178]
push edx
push eax
mov ecx,[eax]
call dword ptr [ecx+20]
test eax,eax
js ErrorsX//Dx11Demo_11.D3DClass::Initialize+76E

/* 비디오카드 메모리 용량 단위를 메가바이트 단위로 저장합니다
	m_videoCardMemory = (int)(adapterDesc.DedicatedVideoMemory / 1024 / 1024)*/
mov eax,[esp+00000288]
shr eax,14 { 20 }
mov [esi+04],eax
lea eax,[esp+00000178]
push 00000080 { 128 }
push eax
push 00000080 { 128 }
lea eax,[esi+08]
mov [esp+54],00000000 { 0 }
push eax
lea eax,[esp+58]
push eax
call ucrtbase.wcstombs_s //dword ptr [Dx11Demo_11._imp__wcstombs_s] { -&gt;ucrtbase.wcstombs_s }
add esp,14 { 20 }
test eax,eax
jne ErrorsX//Dx11Demo_11.D3DClass::Initialize+76E
/*	// 디스플레이 모드 리스트를 해제합니다
	delete[] displayModeList;*/

push [esp+24]
call ucrtbase.free//"Dx11Demo_11.operator delete[]"/////////////////////

/*	// 출력 어뎁터를 해제합니다
	adapterOutput-&gt;Release();*/
mov eax,[esp+14]
add esp,04 { 4 }
mov ecx,[eax]
push eax
call dword ptr [ecx+08]

/*어뎁터를 해제합니다adapter-&gt;Release()*/
mov eax,[esp+14]
mov [esp+10],00000000 { 0 }
push eax
mov ecx,[eax]
call dword ptr [ecx+08]

/*	// 팩토리 객체를 해제합니다
	factory-&gt;Release();*/

mov eax,[esp+1C]
mov [esp+14],00000000 { 0 }
push eax
mov ecx,[eax]
call dword ptr [ecx+08]
/*
// 스왑체인 구조체를 초기화합니다
	DXGI_SWAP_CHAIN_DESC swapChainDesc;
	ZeroMemory(&amp;swapChainDesc, sizeof(swapChainDesc));

	// 백버퍼를 1개만 사용하도록 지정합니다
	swapChainDesc.BufferCount = 1;

	// 백버퍼의 넓이와 높이를 지정합니다
	swapChainDesc.BufferDesc.Width = screenWidth;
	swapChainDesc.BufferDesc.Height = screenHeight;

	// 32bit 서페이스를 설정합니다
	swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;

	// 백버퍼의 새로고침 비율을 설정합니다
	if (m_vsync_enabled)
*/

/*if (m_vsync_enabled)*/
cmp byte ptr [esi],00 { 0 }
mov eax,[ebp+08] //[screenWidth]   08
mov [esp+1C],00000000 { 0 }
mov [esp+78],00000001 { 1 }
mov [esp+50],eax
mov [esp+54],edi
mov [esp+60],0000001C { 28 }
je elseX//Dx11Demo_11.D3DClass::Initialize+1F2
//swapChainDesc.BufferDesc.RefreshRate.Numerator = numerator;
mov eax,[esp+28]
mov [esp+58],eax
//swapChainDesc.BufferDesc.RefreshRate.Denominator = denominator;
mov eax,[esp+2C]
mov [esp+5C],eax
jmp goto6// epb+14 Dx11Demo_11.D3DClass::Initialize+202
elseX:
mov [esp+58],00000000 { 0 }
mov [esp+5C],00000001 { 1 }

/*

// 백버퍼의 사용용도를 지정합니다
	swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;

	// 랜더링에 사용될 윈도우 핸들을 지정합니다
	swapChainDesc.OutputWindow = hwnd;
00401B62  mov         eax,dword ptr [hwnd]

	// 멀티샘플링을 끕니다
	swapChainDesc.SampleDesc.Count = 1;
	swapChainDesc.SampleDesc.Quality = 0;

*/

/*

if (fullscreen)
	{
		swapChainDesc.Windowed = false;
	}
	else
	{
		swapChainDesc.Windowed = true;
	}

	// 스캔 라인 순서 및 크기를 지정하지 않음으로 설정합니다.
	swapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
	swapChainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;

	// 출력된 다음 백버퍼를 비우도록 지정합니다
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	// 추가 옵션 플래그를 사용하지 않습니다
	swapChainDesc.Flags = 0;

	// 피처레벨을 DirectX 11 로 설정합니다
	D3D_FEATURE_LEVEL featureLevel = D3D_FEATURE_LEVEL_11_0;

	// 스왑 체인, Direct3D 장치 및 Direct3D 장치 컨텍스트를 만듭니다.
	if (FAILED(D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, 0, &amp;featureLevel, 1,
*/

goto6:
mov eax,[ebp+14] //[hwnd]
lea ecx,[esi+00000090]
push ecx
push 00 { 0 }
mov [esp+00000084],eax
lea edx,[esi+00000088]
lea eax,[esi+0000008C]
mov [esp+7C],00000020 { 32 }
push eax
push edx
lea eax,[esp+60]
mov [esp+7C],00000001 { 1 }
push eax
push 07 { 7 }
push 01 { 1 }
lea eax,[esp+68]
mov [esp+0000008C],00000000 { 0 }
push eax
push 00 { 0 }
push 00 { 0 }
push 01 { 1 }
push 00 { 0 }
mov [esp+000000B0],00000001 { 1 }
mov [esp+00000094],00000000 { 0 }
mov [esp+00000098],00000000 { 0 }
mov [esp+000000B4],00000000 { 0 }
mov [esp+000000B8],00000000 { 0 }
mov [esp+7C],0000B000 { 45056 }
call d3d11.D3D11CreateDeviceAndSwapChain//dword ptr [Dx11Demo_11._imp__D3D11CreateDeviceAndSwapChain] { -&gt;d3d11.D3D11CreateDeviceAndSwapChain }
test eax,eax
js ErrorsX//Dx11Demo_11.D3DClass::Initialize+76E

/*
// 백버퍼 포인터를 얻어옵니다
	ID3D11Texture2D* backBufferPtr = nullptr;
	if (FAILED(m_swapChain-&gt;GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&amp;backBufferPtr)))
*/

mov eax,[esi+00000088]
lea edx,[esp+20]
push edx
push guiDx3ID2//Dx11Demo_11._GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c { (1863690994) }
mov [esp+28],00000000 { 0 }
mov ecx,[eax]
push 00 { 0 }
push eax
call dword ptr [ecx+24]
test eax,eax
js ErrorsX//Dx11Demo_11.D3DClass::Initialize+76E

/*
// 백 버퍼 포인터로 렌더 타겟 뷰를 생성한다.
	if (FAILED(m_device-&gt;CreateRenderTargetView(backBufferPtr, NULL, &amp;m_renderTargetView)))
*/

mov eax,[esi+0000008C]
lea edx,[esi+00000094]
push edx
push 00 { 0 }
push [esp+28]
mov ecx,[eax]
push eax
call dword ptr [ecx+24]
test eax,eax
js ErrorsX//Dx11Demo_11.D3DClass::Initialize+76E

/*
// 백버퍼 포인터를 해제합니다
	backBufferPtr-&gt;Release();
*/

mov eax,[esp+20]
push eax
mov ecx,[eax]
call dword ptr [ecx+08]

/*
// 깊이 버퍼 구조체를 초기화합니다
	D3D11_TEXTURE2D_DESC depthBufferDesc;
	ZeroMemory(&amp;depthBufferDesc, sizeof(depthBufferDesc));

	// 깊이 버퍼 구조체를 작성합니다
	depthBufferDesc.Width = screenWidth;
00401C54  mov         eax,dword ptr [screenWidth]
	depthBufferDesc.Height = screenHeight;
	depthBufferDesc.MipLevels = 1;
	depthBufferDesc.ArraySize = 1;
	depthBufferDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	depthBufferDesc.SampleDesc.Count = 1;
	depthBufferDesc.SampleDesc.Quality = 0;
	depthBufferDesc.Usage = D3D11_USAGE_DEFAULT;
	depthBufferDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
	depthBufferDesc.CPUAccessFlags = 0;
	depthBufferDesc.MiscFlags = 0;
*/

mov eax,[ebp+08] //[screenWidth]

/*
// 설정된 깊이버퍼 구조체를 사용하여 깊이 버퍼 텍스쳐를 생성합니다
	if (FAILED(m_device-&gt;CreateTexture2D(&amp;depthBufferDesc, NULL, &amp;m_depthStencilBuffer)))
*/

lea edx,[esi+00000098]
mov [esp+000000CC],eax
mov eax,[esi+0000008C]
push edx
push 00 { 0 }
mov [esp+28],00000000 { 0 }
lea edx,[esp+000000D4]
mov [esp+000000D8],edi
mov [esp+000000DC],00000001 { 1 }
mov [esp+000000E0],00000001 { 1 }
mov [esp+000000E4],0000002D { 45 }
mov [esp+000000E8],00000001 { 1 }
mov [esp+000000EC],00000000 { 0 }
mov [esp+000000F0],00000000 { 0 }
mov [esp+000000F4],00000040 { 64 }
mov [esp+000000F8],00000000 { 0 }
mov [esp+000000FC],00000000 { 0 }
mov ecx,[eax]
push edx
push eax
call dword ptr [ecx+14]
test eax,eax
js ErrorsX//Dx11Demo_11.D3DClass::Initialize+76E

/*
	return false;
	}

	// 스텐실 상태 구조체를 초기화합니다
	D3D11_DEPTH_STENCIL_DESC depthStencilDesc;
	ZeroMemory(&amp;depthStencilDesc, sizeof(depthStencilDesc));

	// 스텐실 상태 구조체를 작성합니다
	depthStencilDesc.DepthEnable = true;
00401CF5  movaps      xmm0,xmmword ptr [__xmm@00000001000000020000000100000001 (04066E0h)]
	depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
	depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS;

	depthStencilDesc.StencilEnable = true;
	depthStencilDesc.StencilReadMask = 0xFF;
	depthStencilDesc.StencilWriteMask = 0xFF;

	// 픽셀 정면의 스텐실 설정입니다
	depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
	depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

	// 픽셀 뒷면의 스텐실 설정입니다
	depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
	depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

	// 깊이 스텐실 상태를 생성합니다
	if (FAILED(m_device-&gt;CreateDepthStencilState(&amp;depthStencilDesc, &amp;m_depthStencilState)))
*/


movaps xmm0,[woncode] { (1) } //[__xmm@00000001000000020000000100000001
lea edx,[esi+0000009C]
mov eax,[esi+0000008C]
movups [esp+00000110],xmm0
push edx
movaps xmm0,[woncode] { (1) }
lea edx,[esp+00000114]
movups [esp+00000128],xmm0
mov [esp+00000124],0000FFFF { 65535 }
movaps xmm0,[woncode] { (1) }
movups [esp+00000138],xmm0
mov ecx,[eax]
push edx
push eax
call dword ptr [ecx+54]
test eax,eax
js ErrorsX//Dx11Demo_11.D3DClass::Initialize+76E


/*
// 깊이 스텐실 상태를 설정합니다
	m_deviceContext-&gt;OMSetDepthStencilState(m_depthStencilState, 1);
*/

mov eax,[esi+00000090]
push 01 { 1 }
push [esi+0000009C]
mov ecx,[eax]
push eax
call dword ptr [ecx+00000090]

/*
// 깊이 스텐실 뷰의 구조체를 초기화합니다
	D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;
	ZeroMemory(&amp;depthStencilViewDesc, sizeof(depthStencilViewDesc));

	// 깊이 스텐실 뷰 구조체를 설정합니다
	depthStencilViewDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	depthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;
	depthStencilViewDesc.Texture2D.MipSlice = 0;

	// 깊이 스텐실 뷰를 생성합니다
	if (FAILED(m_device-&gt;CreateDepthStencilView(m_depthStencilBuffer, &amp;depthStencilViewDesc, &amp;m_depthStencilView)))
*/

mov eax,[esi+0000008C]
lea edx,[esi+000000A0]
push edx
lea edx,[esp+000000FC]
mov [esp+00000104],00000000 { 0 }
xorps xmm0,xmm0
mov [esp+000000FC],0000002D { 45 }
push edx
push [esi+00000098]
movlpd [esp+00000114],xmm0
mov [esp+00000108],00000003 { 3 }
mov [esp+00000110],00000000 { 0 }
mov ecx,[eax]
push eax
call dword ptr [ecx+28]
test eax,eax
js ErrorsX//Dx11Demo_11.D3DClass::Initialize+76E

/*
// 렌더링 대상 뷰와 깊이 스텐실 버퍼를 출력 렌더 파이프 라인에 바인딩합니다
	m_deviceContext-&gt;OMSetRenderTargets(1, &amp;m_renderTargetView, m_depthStencilView);
*/

mov eax,[esi+00000090]
lea edx,[esi+00000094]
push [esi+000000A0]
push edx
mov ecx,[eax]
push 01 { 1 }
push eax
call dword ptr [ecx+00000084]

/*
// 그려지는 폴리곤과 방법을 결정할 래스터 구조체를 설정합니다
	D3D11_RASTERIZER_DESC rasterDesc;
	rasterDesc.AntialiasedLineEnable = false;
	rasterDesc.CullMode = D3D11_CULL_BACK;
	rasterDesc.DepthBias = 0;
	rasterDesc.DepthBiasClamp = 0.0f;
	rasterDesc.DepthClipEnable = true;
	rasterDesc.FillMode = D3D11_FILL_SOLID;
	rasterDesc.FrontCounterClockwise = false;
	rasterDesc.MultisampleEnable = false;
	rasterDesc.ScissorEnable = false;
	rasterDesc.SlopeScaledDepthBias = 0.0f;

	// 방금 작성한 구조체에서 래스터 라이저 상태를 만듭니다
	if (FAILED(m_device-&gt;CreateRasterizerState(&amp;rasterDesc, &amp;m_rasterState)))
*/


mov eax,[esi+0000008C]
lea edx,[esi+000000A4]
push edx
mov [esp+000000CC],00000000 { 0 }
lea edx,[esp+000000A8]
mov [esp+000000AC],00000003 { 3 }
mov [esp+000000B4],00000000 { 0 }
mov [esp+000000B8],00000000 { 0 }
mov [esp+000000C0],00000001 { 1 }
mov [esp+000000A8],00000003 { 3 }
mov [esp+000000B0],00000000 { 0 }
mov [esp+000000C8],00000000 { 0 }
mov [esp+000000C4],00000000 { 0 }
mov [esp+000000BC],00000000 { 0 }
mov ecx,[eax]
push edx
push eax
call dword ptr [ecx+58]
test eax,eax
js ErrorsX//Dx11Demo_11.D3DClass::Initialize+76E

/*
{
		return false;
	}

	// 이제 래스터 라이저 상태를 설정합니다
	m_deviceContext-&gt;RSSetState(m_rasterState);
*/

mov eax,[esi+00000090]
push [esi+000000A4]
push eax
mov ecx,[eax]
call dword ptr [ecx+000000AC]
movd xmm0,[ebp+08]//[screenWidth]

// 뷰포트를 생성합니다
//	m_deviceContext-&gt;RSSetViewports(1, &amp;viewport);
lea edx,[esp+0000008C]
mov eax,[esi+00000090]
cvtdq2ps xmm0,xmm0//[screenWidth]
push edx
mov [esp+000000A0],00000000 { 0 }
mov [esp+000000A4],3F800000 { 1.00 }
mov [esp+00000090],00000000 { 0 }
mov [esp+00000094],00000000 { 0 }
movss [esp+00000098],xmm0
movd xmm0,[ebp+0C]
cvtdq2ps xmm0,xmm0
push 01 { 1 }
push eax
movss [esp+000000A4],xmm0
mov ecx,[eax]
call dword ptr [ecx+000000B0]
movd xmm0,[ebp+08]
xorps xmm4,xmm4

/* 투영 행렬을 설정합니다
float fieldOfView = XM_PI / 4.0f;float screenAspect = (float)screenWidth / (float)screenHeight; 00401EFB  cvtdq2ps    xmm1,xmm0  */

cvtdq2ps xmm1,xmm0

/*3D 렌더링을위한 투영 행렬을 만듭니다
	m_projectionMatrix = XMMatrixPerspectiveFovLH(fieldOfView, screenAspect, screenNear, screenDepth);*/

mov [esp+34],401A8279 { 2.41 }
movd xmm0,[ebp+0C]
movss xmm2,[ebp+1C]
movss xmm7,[ebp+20]
movaps xmm6,xmm2

/*	// 투영 행렬을 설정합니다
	float fieldOfView = XM_PI / 4.0f;
	float screenAspect = (float)screenWidth / (float)screenHeight;
00401F18  cvtdq2ps    xmm0,xmm0  */

cvtdq2ps xmm0,xmm0
/*3D 렌더링을위한 투영 행렬을 만듭니다.*/
subss xmm6,xmm7

/*투영 행렬을 설정합니다
	float fieldOfView = XM_PI / 4.0f;
	float screenAspect = (float)screenWidth / (float)screenHeight;*/
divss xmm1,xmm0

/*3D 렌더링을위한 투영 행렬을 만듭니다
	m_projectionMatrix = XMMatrixPerspectiveFovLH(fieldOfView, screenAspect, screenNear, screenDepth);*/
movss xmm0,[woncode+38]//[Dx11Demo_11._real] { (2.41) } //[__real@401a8279 (04066A8h)]

/*
	m_projectionMatrix = XMMatrixPerspectiveFovLH(fieldOfView, screenAspect, screenNear, screenDepth);
00401F23  movss       xmm0,dword ptr [__real@401a8279 (04066A8h)]
00401F2B  divss       xmm0,xmm1
00401F2F  divss       xmm2,xmm6
00401F33  movss       dword ptr [esp+30h],xmm0
00401F39  movaps      xmm1,xmm2
00401F3C  movss       dword ptr [esp+38h],xmm2
00401F42  xorps       xmm1,xmmword ptr [__xmm@80000000800000008000000080000000 (0406720h)]
00401F49  xorps       xmm2,xmm2
00401F4C  mulss       xmm1,xmm7
00401F50  movss       dword ptr [esp+3Ch],xmm1
00401F56  movaps      xmm1,xmmword ptr [esp+30h]
00401F5B  movss       xmm4,xmm1
00401F5F  movaps      xmm3,xmm1
00401F62  shufps      xmm1,xmmword ptr [DirectX::g_XMIdentityR3 (0406370h)],0EEh
00401F6A  andps       xmm3,xmmword ptr [DirectX::g_XMMaskY (04063C0h)]
00401F71  shufps      xmm2,xmm1,0C0h
00401F75  movups      xmmword ptr [esi+0B0h],xmm4
00401F7C  movups      xmmword ptr [esi+0C0h],xmm3
00401F83  movaps      xmm0,xmm2
00401F86  xorps       xmm4,xmm4
00401F89  shufps      xmm0,xmm1,90h
00401F8D  movups      xmmword ptr [esi+0D0h],xmm2
00401F94  movups      xmmword ptr [esi+0E0h],xmm0
*/

divss xmm0,xmm1
divss xmm2,xmm6
movss [esp+30],xmm0
movaps xmm1,xmm2
movss [esp+38],xmm2
xorps xmm1,[woncode+40]
xorps xmm2,xmm2
mulss xmm1,xmm7
movss [esp+3C],xmm1
movaps xmm1,[esp+30]
movss xmm4,xmm1
movaps xmm3,xmm1
shufps xmm1,[IDENTY3],-12//[Dx11Demo_11.DirectX::g_XMIdentityR3],-12 { 238,(0.00) }
andps xmm3,[IDENTY3+50]//Dx11Demo_11.DirectX::g_XMMaskY] { (0) }
shufps xmm2,xmm1,-40 { 192 }
movups [esi+000000B0],xmm4
movups [esi+000000C0],xmm3
movaps xmm0,xmm2
xorps xmm4,xmm4
shufps xmm0,xmm1,-70 { 144 }
movups [esi+000000D0],xmm2
movups [esi+000000E0],xmm0

// 세계 행렬을 항등 행렬로 초기화합니다
	//m_worldMatrix = XMMatrixIdentity();
mov eax,IDENTY3
add eax,20
movaps xmm0,[eax]//[Dx11Demo_11.DirectX::g_XMIdentityR0] { (1.00) }
movaps xmm1,[eax+10]//[Dx11Demo_11.DirectX::g_XMIdentityR1] { (0.01) }
movaps xmm2,[eax+20]//[Dx11Demo_11.DirectX::g_XMIdentityR2] { (0) }
movaps xmm3,[eax-20]
//movaps xmm3,[IDENTYR3-20]//[Dx11Demo_11.DirectX::g_XMIdentityR3] { (0) }
movups [esi+000000F0],xmm0
movups [esi+00000100],xmm1
movd xmm1,[ebp+08] //[screenWidth]

// 2D 렌더링을위한 직교 투영 행렬을 만듭니다
//	m_orthoMatrix = XMMatrixOrthographicLH((float)screenWidth, (float)screenHeight, screenNear, screenDepth);
cvtdq2ps xmm1,xmm1

// 세계 행렬을 항등 행렬로 초기화합니다
//	m_worldMatrix = XMMatrixIdentity();
//00401FCD  movups      xmmword ptr [esi+110h],xmm2
movups [esi+00000110],xmm2

// 2D 렌더링을위한 직교 투영 행렬을 만듭니다
/*	m_orthoMatrix = XMMatrixOrthographicLH((float)screenWidth, (float)screenHeight, screenNear, screenDepth);
00401FD4  movss       xmm2,dword ptr [__real@40000000 (04066A4h)]*/

movss xmm2,[imageFloatD3D] { (2.00) }

/*
// 세계 행렬을 항등 행렬로 초기화합니다
	m_worldMatrix = XMMatrixIdentity();
00401FDC  movups      xmmword ptr [esi+120h],xmm3
*/
movups [esi+00000120],xmm3

// 2D 렌더링을위한 직교 투영 행렬을 만듭니다
//	m_orthoMatrix = XMMatrixOrthographicLH((float)screenWidth, (float)screenHeight, screenNear, screenDepth);
//    */
movss xmm3,[imageFloatD3D-4] { (1.00) }//jmp
movaps xmm0,xmm2
divss xmm0,xmm1
movd xmm1,[ebp+0C]//[screenHeight]
divss xmm3,xmm6
cvtdq2ps xmm1,xmm1
movss [esp+30],xmm0//xmm0
divss xmm2,xmm1
movaps xmm1,xmm3
movss [esp+38],xmm3//xmm3
xorps xmm1,[woncode+40]//[__xmm@80000000800000008000000080000000 (0406720h)]
mulss xmm1,xmm7
movss [esp+34],xmm2
movss [esp+3C],xmm1
movaps xmm1,[esp+30]

/*
depthDisabledStencilDesc.StencilWriteMask = 0xFF;
	depthDisabledStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
	depthDisabledStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
	depthDisabledStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
	depthDisabledStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
*/

/*
// 장치를 사용하여 상태를 만듭니다.
	if (FAILED (m_device-&gt; CreateDepthStencilState (&amp; depthDisabledStencilDesc, &amp; m_depthDisabledStencilState)))
*/

lea eax,[esi+00000170]
mov ecx,[esi+0000008C]
xorps xmm3,xmm3

/*
// 2D 렌더링을위한 직교 투영 행렬을 만듭니다
	m_orthoMatrix = XMMatrixOrthographicLH((float)screenWidth, (float)screenHeight, screenNear, screenDepth);
0040203C  movss       xmm3,xmm1
*/
movss xmm3,xmm1

/*이제 2D 렌더링을위한 Z 버퍼를 끄는 두 번째 깊이 스텐실 상태를 만듭니다. 유일한 차이점은
	// DepthEnable을 false로 설정하면 다른 모든 매개 변수는 다른 깊이 스텐실 상태와 동일합니다.
	D3D11_DEPTH_STENCIL_DESC depthDisabledStencilDesc;
	ZeroMemory(&amp;depthDisabledStencilDesc, sizeof(depthDisabledStencilDesc));

	depthDisabledStencilDesc.DepthEnable = false;
	depthDisabledStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
	depthDisabledStencilDesc.DepthFunc = D3D11_COMPARISON_LESS;
	depthDisabledStencilDesc.StencilEnable = true;
	depthDisabledStencilDesc.StencilReadMask = 0xFF;*/
mov [esp+00000154],0000FFFF { 65535 }


/// 2D 렌더링을위한 직교 투영 행렬을 만듭니다
/*	m_orthoMatrix = XMMatrixOrthographicLH((float)screenWidth, (float)screenHeight, screenNear, screenDepth);
0040204B  movaps      xmm2,xmm1
0040204E  shufps      xmm1,xmmword ptr [DirectX::g_XMIdentityR3 (0406370h)],0EEh
00402056  andps       xmm2,xmmword ptr [DirectX::g_XMMaskY (04063C0h)]
0040205D  shufps      xmm4,xmm1,80h
00402061  movups      xmmword ptr [esi+130h],xmm3
	depthDisabledStencilDesc.StencilWriteMask = 0xFF;
	depthDisabledStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
	depthDisabledStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
	depthDisabledStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
	depthDisabledStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;*/
movaps xmm2,xmm1
shufps xmm1,[IDENTY3],-12//[Dx11Demo_11.DirectX::g_XMIdentityR3],-12 { 238,(0.00) }
andps xmm2,[IDENTY3+50]//[Dx11Demo_11.DirectX::g_XMMaskY] { (0) }
shufps xmm4,xmm1,-80 { 128 }
movups [esi+00000130],xmm3
/*
// 장치를 사용하여 상태를 만듭니다.
	if (FAILED (m_device-&gt; CreateDepthStencilState (&amp; depthDisabledStencilDesc, &amp; m_depthDisabledStencilState)))
*/
push eax

/*2D 렌더링을위한 직교 투영 행렬을 만듭니다
	m_orthoMatrix = XMMatrixOrthographicLH((float)screenWidth, (float)screenHeight, screenNear, screenDepth);
00402069  movaps      xmm0,xmm4  */
movaps xmm0,xmm4

/*
depthDisabledStencilDesc.StencilWriteMask = 0xFF;
	depthDisabledStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
	depthDisabledStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
	depthDisabledStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
	depthDisabledStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

	// 장치를 사용하여 상태를 만듭니다.
	if (FAILED (m_device-&gt; CreateDepthStencilState (&amp; depthDisabledStencilDesc, &amp; m_depthDisabledStencilState)))
0040206C  lea         eax,[esp+148h]
*/

/*2D 렌더링을위한 직교 투영 행렬을 만듭니다
	m_orthoMatrix = XMMatrixOrthographicLH((float)screenWidth, (float)screenHeight, screenNear, screenDepth);
00402073  shufps      xmm0,xmm1,0D0h
00402077  movups      xmmword ptr [esi+140h],xmm2
	depthDisabledStencilDesc.StencilWriteMask = 0xFF;
	depthDisabledStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
	depthDisabledStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
	depthDisabledStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
	depthDisabledStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthDisabledStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
*/
lea eax,[esp+00000148]
shufps xmm0,xmm1,-30 { 208 }
movups [esi+00000140],xmm2

/*장치를 사용하여 상태를 만듭니다.
	if (FAILED (m_device-&gt; CreateDepthStencilState (&amp; depthDisabledStencilDesc, &amp; m_depthDisabledStencilState)))*/

push eax
movups [esi+00000150],xmm4
push ecx
movups [esi+00000160],xmm0
movaps xmm0,[Woncode-10]//[Dx11Demo_11._xmm] { (0) }
movups [esp+00000150],xmm0
movaps xmm0,[Woncode+10]//[Dx11Demo_11._xmm] { (1) }
movups [esp+00000164],xmm0
movaps xmm0,[Woncode+10]//[Dx11Demo_11._xmm] { (1) }
movups [esp+00000174],xmm0
mov edx,[ecx]
call dword ptr [edx+54]
test eax,eax
js ErrorsX//Dx11Demo_11.D3DClass::Initialize+76E
mov al,01 { 1 }
pop edi
pop esi
mov esp,ebp
pop ebp
ret 001C { 28 }
ErrorsX:
pop edi
xor al,al
pop esi
mov esp,ebp
pop ebp
ret 001C { 28 }



[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>898</ID>
              <Description>"GraphicsClassX::DXBitmapClassInitialize::CreateDDSTextureFromFileExDBVMX"</Description>
              <LastState Activated="1"/>
              <Color>0000FF</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]

label(goto1)
label(goto2)
label(goto3)
label(goto4)


CreateDDSTextureFromFileExDBVMX:
push ebp
mov ebp,esp
mov eax,fs:[00000000] { 0 }
push -01 { 255 }
push ErrorSum//Dx11Demo_11.exe+51AD { (144) }
push eax
mov fs:[00000000],esp { 0 }
sub esp,0C { 12 }
push ebx
push esi
mov esi,[ebp+28]
mov ebx,ecx
test esi,esi
je goto1//Dx11Demo_11.DirectX::CreateDDSTextureFromFileEx+2C
mov [esi],00000000 { 0 }
goto1:
test ebx,ebx
je goto2//Dx11Demo_11.DirectX::CreateDDSTextureFromFileEx+C6
test esi,esi
je goto2//Dx11Demo_11.DirectX::CreateDDSTextureFromFileEx+C6
push edi
mov [ebp-14],00000000 { 0 }
mov [ebp-10],00000000 { 0 }
mov [ebp+28],00000000 { 0 }
mov [ebp-18],00000000 { 0 }
lea eax,[ebp+28]
mov [ebp-04],00000000 { 0 }
push eax
lea eax,[ebp-10]
push eax
lea eax,[ebp-14]
push eax
lea edx,[ebp-18]
call LoadTextureDataFromFileX//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"
mov edi,eax
add esp,0C { 12 }
test edi,edi
js goto3//Dx11Demo_11.DirectX::CreateDDSTextureFromFileEx+A3
push esi
push 00 { 0 }
push 00 { 0 }
push 00 { 0 }
push 00 { 0 }
push 08 { 8 }
push 00 { 0 }
push 00 { 0 }
push [ebp+28]
xor edx,edx
mov ecx,ebx
push [ebp-10]
push [ebp-14]
call CreateTextureFromDDSDBVM//CreateDDSTextureFromFileExDBVMX2////"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"
add esp,2C { 44 }
mov edi,eax
goto3:
mov eax,[ebp-18]
test eax,eax
je goto4//Dx11Demo_11.DirectX::CreateDDSTextureFromFileEx+B3
push eax
call ucrtbase.free
add esp,04 { 4 }
goto4:
mov eax,edi
pop edi
pop esi
pop ebx
mov ecx,[ebp-0C]
mov fs:[00000000],ecx { 0 }
mov esp,ebp
pop ebp
ret
goto2:
mov ecx,[ebp-0C]
mov eax,80070057 { -2147024809 }
pop esi
pop ebx
mov fs:[00000000],ecx { 0 }
mov esp,ebp
pop ebp
ret



[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>899</ID>
                  <Description>"GraphicsClassX::DXBitmapClassInitialize::CreateDDSTextureFromFileExDBVMX::LoadTextureDataFromFileX"</Description>
                  <LastState Activated="1"/>
                  <Color>0000FF</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

label(ErrorX1)
label(ErrorX2)
label(ErrorX3)
label(NullNot)
label(closeHXX)
label(Error156)
label(EndEW)

ddsPath: //push Dx11Demo_11.exe+64D8 { ("../Dx11Demo_11/data/seafloor.dd") }
db 2E 00 2E 00 2F 00 44 00 78 00 31 00 31 00 44 00 65 00 6D 00 6F 00 5F 00 31 00 31 00 2F 00 64 00 61 00 74 00 61 00 2F 00 73 00 65 00 61 00 66 00 6C 00 6F 00 6F 00 72 00 2E 00 64 00 64 00 73 00 00 00 00 00 00 00 00 00

LoadTextureDataFromFileX:
push ebp
mov ebp,esp
sub esp,1C { 28 }
cmp dword ptr [ebp+08],00 { 0 }
push edi
mov edi,edx
je ErrorX1//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+16F { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+16F }
cmp dword ptr [ebp+0C],00 { 0 }
je ErrorX1//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+16F { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+16F }
cmp dword ptr [ebp+10],00 { 0 }
je ErrorX1 //"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+16F { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+16F }
push ebx
push esi
push 00 { 0 }
push 00000080 { 128 }
push 03 { 3 }
push 00 { 0 }
push 01 { 1 }
push 80000000 { -2147483648 }
push ddsPath//Dx11Demo_11.exe+64D8 { ("../Dx11Demo_11/data/seafloor.dd") }
call KERNELBASE.CreateFileW
mov esi,eax
xor eax,eax
cmp esi,-01 { 255 }
cmove esi,eax
test esi,esi
je ErrorX2//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+CA { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+CA }
push 18 { 24 }
lea eax,[ebp-1C]
push eax
push 01 { 1 }
push esi
call KERNEL32.GetFileInformationByHandleEx//dword ptr [Dx11Demo_11._imp__GetFileInformationByHandleEx] { -&gt;KERNEL32.GetFileInformationByHandleEx }
test eax,eax
je ErrorX2//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+CA { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+CA }
cmp dword ptr [ebp-10],00 { 0 }
jg ErrorX3//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+156 { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+156 }
mov eax,[ebp-14]
cmp eax,00000080 { 128 }
jb ErrorX3//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+156 { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+156 }
push 00//Dx11Demo_11.std::nothrow { (0) }
push eax
call OperX//"Dx11Demo_11.operator new[]"
mov ecx,[edi]
add esp,08 { 8 }
mov [edi],eax
test ecx,ecx
je NullNot//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+A0 { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+A0 }
push ecx
call ucrtbase.free
mov eax,[edi]
add esp,04 { 4 }
NullNot:
test eax,eax
jne zerogate//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+AE { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+AE }
mov edi,8007000E { -2147024882 }
jmp closeHXX//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+15B { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+15B }
zerogate:
push 00 { 0 }
lea ecx,[ebp-04]
mov [ebp-04],00000000 { 0 }
push ecx
push [ebp-14]
push eax
push esi
call KERNELBASE.ReadFile//dword ptr [Dx11Demo_11._imp__ReadFile] { -&gt;-&gt;KERNELBASE.ReadFile }
test eax,eax
jne Error156//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+E5 { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+E5 }
ErrorX2:
call KERNELBASE.GetLastError //dword ptr [Dx11Demo_11._imp__GetLastError] { -&gt;-&gt;KERNELBASE.GetLastError }
mov edi,eax
test edi,edi
jng closeHXX//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+15B { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+15B }
movzx edi,di
or edi,80070000 { -2147024896 }
jmp closeHXX//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+15B { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+15B }
Error156:
mov edx,[ebp-14]
cmp [ebp-04],edx
jb ErrorX3//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+156 { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+156 }
mov eax,[edi]
cmp [eax],20534444 { "DDS " }
jne ErrorX3//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+156 { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+156 }
add eax,04 { 4 }
cmp dword ptr [eax],7C { 124 }
jne ErrorX3//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+156 { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+156 }
cmp dword ptr [eax+48],20 { 32 }
jne ErrorX3//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+156 { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+156 }
xor bl,bl
test byte ptr [eax+4C],04 { 4 }
je ebpaccX//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+120 { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+120 }
cmp [eax+50],30315844 { "DX10" }
jne ebpaccX//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+120 { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+120 }
cmp edx,00000094 { 148 }
jb ErrorX3//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+156 { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+156 }
mov bl,01 { 1 }
ebpaccX:
mov ecx,[ebp+08]
test bl,bl
push esi
mov [ecx],eax
mov eax,00000094 { 148 }
mov ecx,00000080 { 128 }
cmovne ecx,eax
mov eax,[edi]
mov edi,[ebp+0C]
add eax,ecx
sub edx,ecx
mov [edi],eax
xor edi,edi
mov eax,[ebp+10]
mov [eax],edx
call KERNELBASE.CloseHandle//dword ptr [Dx11Demo_11._imp__CloseHandle] { -&gt;-&gt;KERNELBASE.CloseHandle }
pop esi
pop ebx
mov eax,edi
pop edi
mov esp,ebp
pop ebp
ret
ErrorX3:
mov edi,80004005 { -2147467259 }
closeHXX:
test esi,esi
je EndEW//"Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile"+166 { -&gt;Dx11Demo_11.`anonymous namespace'::LoadTextureDataFromFile+166 }
push esi
call KERNELBASE.CloseHandle//dword ptr [Dx11Demo_11._imp__CloseHandle] { -&gt;-&gt;KERNELBASE.CloseHandle }
EndEW:
pop esi
pop ebx
mov eax,edi
pop edi
mov esp,ebp
pop ebp
ret
ErrorX1:
mov eax,80004003 { -2147467261 }
pop edi
mov esp,ebp
pop ebp
ret

 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>900</ID>
      <Description>"GraphicsClassX::TextureShaderClassDBVM"</Description>
      <LastState Activated="1"/>
      <Color>008000</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]


DX3ME1:
db 'vs_5_0' 00
DX3ME2:
db 'TextureVertexShader' 00
DX3ME3:
db 2E 00 2E 00 2F 00 44 00 78 00 31 00 31 00 44 00 65 00 6D 00 6F 00 5F 00 31 00 31 00 2F 00 74 00 65 00 78 00 74 00 75 00 72 00 65 00 2E 00 76 00 73 00 00 00//
//'../Dx11Demo_11/texture.vs'
DX3ME4:
db 'ps_5_0' 00
DX3ME5:
db 'TexturePixelShader' 00
DX3ME6:
db 2E 00 2E 00 2F 00 44 00 78 00 31 00 31 00 44 00 65 00 6D 00 6F 00 5F 00 31 00 31 00 2F 00 74 00 65 00 78 00 74 00 75 00 72 00 65 00 2E 00 70 00 73 00 00 00 2E 00 2E 00 2F 00 44 00 78 00 31 00 31 00 44 00 65 00 6D 00 6F 00 5F 00 31 00 31 00 2F 00 74 00 65 00 78 00 74 00 75 00 72 00 65 00 2E 00 76 00 73 00 00 00
//'../Dx11Demo_11/texture.vs'
DX3ME7:
db 'POSITION' 00
DX3ME8:
db 'TEXCOORD' 00


PointerAPI2:
dd D3DCOMPILER_47.D3DCompileFromFile

label(Class2TEST)
TextureShaderClassDBVM:
push ebp
mov ebp,esp
sub esp,00000090 { 144 }
push ebx
push esi
mov esi,[PointerAPI2] { (626CC990) }
lea eax,[ebp-0C]
push edi
push eax
lea eax,[ebp-04]
mov [ebp-0C],00000000 { 0 }
push eax
push 00 { 0 }
push 00000800 { 2048 }
push DX3ME1//Dx11Demo_11.exe+65F0 { ("vs_5_0") }
push DX3ME2//Dx11Demo_11.exe+65F8 { ("TextureVertexShader") }
push 00 { 0 }
push 00 { 0 }
push DX3ME3//Dx11Demo_11.exe+65BC { ("../Dx11Demo_11/texture.vs") }
mov ebx,ecx
mov [ebp-04],00000000 { 0 }
call esi
test eax,eax
jns Class2TEST//Dx11Demo_11.TextureShaderClass::InitializeShader+A4
mov [ErrorDebug],5
ret


label(Class3TEST)

Class2TEST:
lea eax,[ebp-0C]
mov [ebp-08],00000000 { 0 }
push eax
lea eax,[ebp-08]
push eax
push 00 { 0 }
push 00000800 { 2048 }
push DX3ME4//Dx11Demo_11.exe+6634 { ("ps_5_0") }
push DX3ME5//Dx11Demo_11.exe+663C { ("TexturePixelShader") }
push 00 { 0 }
push 00 { 0 }
push DX3ME6//Dx11Demo_11.exe+6588 { ("../Dx11Demo_11/texture.ps") }
call esi
test eax,eax
jns Class3TEST//Dx11Demo_11.TextureShaderClass::InitializeShader+119
mov [ErrorDebug],2
ret

label(Class3TESTError)

Class3TESTError:
mov [ErrorDebug],3
ret

Class3TEST:
mov eax,[ebp-04]
mov edi,[ebp+08]
push ebx
push 00 { 0 }
mov ecx,[eax]
mov esi,[edi]
push eax
call dword ptr [ecx+10]
push eax
mov eax,[ebp-04]
push eax
mov ecx,[eax]
call dword ptr [ecx+0C]
push eax
push edi
call dword ptr [esi+30]
test eax,eax
js Class3TESTError//Dx11Demo_11.TextureShaderClass::InitializeShader+79
mov esi,[edi]
lea eax,[ebx+04]
push eax
mov eax,[ebp-08]
push 00 { 0 }
push eax
mov ecx,[eax]
call dword ptr [ecx+10]
push eax
mov eax,[ebp-08]
push eax
mov ecx,[eax]
call dword ptr [ecx+0C]
push eax
push edi
call dword ptr [esi+3C]
test eax,eax
js Class3TESTError//Dx11Demo_11.TextureShaderClass::InitializeShader+79
mov esi,[edi]
lea eax,[ebx+08]
push eax
mov eax,[ebp-04]
mov [ebp-5C],DX3ME7//Dx11Demo_11.exe+6650 { ("POSITION") }
mov [ebp-58],00000000 { 0 }
mov [ebp-54],00000006 { 6 }
mov [ebp-50],00000000 { 0 }
mov [ebp-4C],00000000 { 0 }
mov [ebp-48],00000000 { 0 }
mov [ebp-44],00000000 { 0 }
mov [ebp-40],DX3ME8//Dx11Demo_11.exe+665C { ("TEXCOORD") }
mov [ebp-3C],00000000 { 0 }
mov [ebp-38],00000010 { 16 }
mov [ebp-34],00000000 { 0 }
mov [ebp-30],FFFFFFFF { -1 }
mov [ebp-2C],00000000 { 0 }
mov [ebp-28],00000000 { 0 }
mov ecx,[eax]
push eax
call dword ptr [ecx+10]
push eax
mov eax,[ebp-04]
push eax
mov ecx,[eax]
call dword ptr [ecx+0C]
push eax
push 02 { 2 }
lea eax,[ebp-5C]
push eax
push edi
call dword ptr [esi+2C]
test eax,eax
js Class3TESTError//Dx11Demo_11.TextureShaderClass::InitializeShader+79
mov eax,[ebp-04]
push eax
mov ecx,[eax]
call dword ptr [ecx+08]
mov eax,[ebp-08]
mov [ebp-04],00000000 { 0 }
push eax
mov ecx,[eax]
call dword ptr [ecx+08]
mov ecx,[edi]
lea eax,[ebx+0C]
push eax
push 00 { 0 }
lea eax,[ebp-24]
mov [ebp-08],00000000 { 0 }
push eax
push edi
mov [ebp-20],00000002 { 2 }
mov [ebp-24],000000C0 { 192 }
mov [ebp-1C],00000004 { 4 }
mov [ebp-18],00010000 { (0) }
mov [ebp-14],00000000 { 0 }
mov [ebp-10],00000000 { 0 }
call dword ptr [ecx+0C]
test eax,eax
js Class3TESTError//Dx11Demo_11.TextureShaderClass::InitializeShader+79
movaps xmm0,[woncode-20]//[Dx11Demo_11._xmm] { (21) }
lea eax,[ebx+10]
mov ecx,[edi]
push eax
lea eax,[ebp-00000090]
mov [ebp-80],00000000 { 0 }
movups [ebp-00000090],xmm0
push eax
xorps xmm0,xmm0
mov [ebp-7C],00000001 { 1 }
push edi
mov [ebp-78],00000008 { 8 }
movups [ebp-74],xmm0
mov [ebp-64],00000000 { 0 }
mov [ebp-60],7F7FFFFF { 2139095039 }
call dword ptr [ecx+5C]
test eax,eax
js Class3TESTError//Dx11Demo_11.TextureShaderClass::InitializeShader+79
pop edi
pop esi
mov al,01 { 1 }
pop ebx
mov esp,ebp
pop ebp
ret 0010 { 16 }


[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>901</ID>
          <Description>"GraphicsClassX::DXBitmapClassInitialize"</Description>
          <LastState Activated="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

label(ProzenX)
label(zegopgen)
label(errorintX)

DXBitmapClassInitialize:
push ebp
mov ebp,esp
sub esp,48 { 72 }
mov eax,[ebp+0C]
push ebx
push esi
mov esi,ecx
push edi
push 78 { 120 }
mov [esi+14],eax
mov eax,[ebp+10]
mov [esi+18],eax
mov [esi+1C],00000100 { 256 }
mov [esi+20],00000100 { 256 }
mov [esi+24],FFFFFFFF { -1 }
mov [esi+28],FFFFFFFF { -1 }
mov [esi+08],00000006 { 6 }
mov [esi+0C],00000006 { 6 }
call operX//"Dx11Demo_11.operator new[]"
mov ecx,[esi+08]
mov ebx,eax
mov [ebp+0C],ebx
lea ecx,[ecx+ecx*4]
shl ecx,02 { 2 }
push ecx
push 00 { 0 }
push ebx
call VCRUNTIME140.memset//Dx11Demo_11.memset { -&gt;-&gt;VCRUNTIME140.memset }
mov eax,[esi+0C]
xor ecx,ecx
mov edx,00000004 { 4 }
mul edx
seto cl
neg ecx
or ecx,eax
push ecx
call operX//"Dx11Demo_11.operator new[]"
xor ecx,ecx
add esp,14 { 20 }
mov edi,eax
cmp [esi+0C],ecx
jle ProzenX//Dx11Demo_11.BitmapClass::Initialize+8D
zegopgen:
mov [edi+ecx*4],ecx
inc ecx
cmp ecx,[esi+0C]
jl zegopgen//Dx11Demo_11.BitmapClass::Initialize+84
ProzenX:
mov eax,[esi+08]
lea ecx,[ebp-0C]
mov [ebp-0C],ebx
mov ebx,[ebp+08]
push esi
lea eax,[eax+eax*4]
mov [ebp-2C],00000002 { 2 }
shl eax,02 { 2 }
push ecx
mov [ebp-30],eax
lea ecx,[ebp-30]
mov eax,[ebx]
push ecx
push ebx
mov [ebp-28],00000001 { 1 }
mov [ebp-24],00010000 { (0) }
mov [ebp-20],00000000 { 0 }
mov [ebp-1C],00000000 { 0 }
mov [ebp-08],00000000 { 0 }
mov [ebp-04],00000000 { 0 }
call dword ptr [eax+0C]
test eax,eax
js errorintX//Dx11Demo_11.BitmapClass::Initialize+17A
mov eax,[esi+0C]
mov ecx,[ebx]
shl eax,02 { 2 }
mov [ebp-48],eax
lea eax,[esi+04]
push eax
lea eax,[ebp-18]
mov [ebp-44],00000000 { 0 }
push eax
lea eax,[ebp-48]
mov [ebp-40],00000002 { 2 }
push eax
push ebx
mov [ebp-3C],00000000 { 0 }
mov [ebp-38],00000000 { 0 }
mov [ebp-34],00000000 { 0 }
mov [ebp-18],edi
mov [ebp-14],00000000 { 0 }
mov [ebp-10],00000000 { 0 }
call dword ptr [ecx+0C]
test eax,eax
js errorintX//Dx11Demo_11.BitmapClass::Initialize+17A
push [ebp+0C]
call ucrtbase.free//"Dx11Demo_11.operator delete[]"
push edi
call ucrtbase.free//"Dx11Demo_11.operator delete[]"
push 04 { 4 }
call operX//"Dx11Demo_11.operator new"
add esp,08 { 8 }
mov [ebp+0C],eax
mov ecx,ebx
mov [eax],00000000 { 0 }
push eax
sub esp,20 { 32 }
mov [esi+10],eax
call CreateDDSTextureFromFileExDBVMX//Dx11Demo_11.DirectX::CreateDDSTextureFromFileEx
add esp,28 { 40 }
test eax,eax
setns al
errorintX:
pop edi
pop esi
pop ebx
mov esp,ebp
pop ebp
ret 0018 { 24 }

 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>902</ID>
              <Description>"GraphicsClassX::DXBitmapClassInitialize::CreateDDSTextureFromFileExDBVMX::CreateTextureFromDDS"</Description>
              <LastState Activated="1"/>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat


label(goto1)
label(goto2)
label(BitsPerPixelDBVM)
label(goto4)
label(goto5)
label(test204)
label(84loop)
label(ebpun10go)
label(nullTest3)
label(cmps0Fs)
label(wonwonun14)
label(inc6c)
label(movecx08)
label(gatego1)
label(gatego2)
label(gatego3)
label(gatew1)
label(gatew2)
label(gatew3)

label(ErrorWowo)


label(gotoa1)
label(gotoa2)
label(gotoa3)
label(gotoa4)
label(gotoa5)
label(gotoa6)

label(goto4un2)

CreateTextureFromDDSDBVM://00402E40
push ebp
mov ebp,esp
push -01 { 255 }
push ErrorSum//Dx11Demo_11.exe+518D { (144) }
mov eax,fs:[00000000] { 0 }
push eax
mov fs:[00000000],esp { 0 }
sub esp,30 { 48 }
mov edx,[ebp+08]
push ebx
push esi
push edi
mov eax,[edx+0C]
xor bl,bl
mov edi,[edx+18]
mov esi,00000001 { 1 }
mov [ebp-18],eax
test edi,edi
mov eax,[edx+08]
mov [ebp-14],eax
mov eax,[edx+14]
mov [ebp-10],eax
mov eax,esi
cmove edi,eax
mov [ebp-3C],ecx
test byte ptr [edx+4C],04 { 4 }
mov [ebp-24],bl
je goto1//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+11E { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+11E }
cmp [edx+50],30315844 { "DX10" }
jne goto1//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+11E { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+11E }
mov esi,[edx+00000088]
test esi,esi
je goto2//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+108 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+108 }
mov ecx,[edx+7C]
mov [ebp-20],ecx
lea eax,[ecx-6F]
cmp eax,03 { 3 }
ja BitsPerPixelDBVM//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+84 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+84 }
jmp goto4//Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5//dword ptr [eax*4+"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+3E0]
BitsPerPixelDBVM:
call NameSpaceBitsPixelX//"Dx11Demo_11.`anonymous namespace'::BitsPerPixel"
test eax,eax
je goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
mov ecx,[edx+00000080]
mov eax,ecx
mov [ebp+08],ecx
sub eax,02 { 2 }
je test204//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+E9 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+E9 }
sub eax,01 { 1 }
je 84loop//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+C2 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+C2 }
sub eax,01 { 1 }
jne goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
test [edx+04],00800000//Dx11Demo_11.exe+400000 { 00800000 }
je goto2//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+108 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+108 }
cmp esi,01 { 1 }
jna ebpun10go//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+103 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+103 }
jmp goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
84loop:
mov eax,[edx+00000084]
and eax,04 { 4 }
je nullTest3//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+D2 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+D2 }
lea esi,[esi+esi*2]
add esi,esi
nullTest3:
test eax,eax
mov [ebp-10],00000001 { 1 }
mov edx,[ebp-10]
setne bl
mov [ebp-24],bl
jmp cmps0Fs//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+170 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+170 }
test204:
test byte ptr [edx+04],02 { 2 }
je wonwonun14//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+F5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+F5 }
cmp dword ptr [ebp-14],01 { 1 }
jne goto2//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+108 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+108 }
wonwonun14:
mov [ebp-14],00000001 { 1 }
mov [ebp-10],00000001 { 1 }
ebpun10go:
mov edx,[ebp-10]
jmp cmps0Fs//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+170 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+170 }
goto2:
pop edi
pop esi
mov eax,8007000D { -2147024883 }
pop ebx
mov ecx,[ebp-0C]
mov fs:[00000000],ecx { 0 }
mov esp,ebp
pop ebp
ret
goto1:
lea ecx,[edx+48]
call GetDXGIFormatDBVM//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"
mov [ebp-20],eax
test eax,eax
je goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
test [edx+04],00800000//Dx11Demo_11.exe+400000 { 00800000 }
je inc6c//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+140 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+140 }
mov edx,[ebp-10]
mov ecx,00000004 { 4 }
jmp movecx08//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+16D { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+16D }
inc6c:
mov eax,[edx+6C]
test eax,00000200 { 512 }
je goto5//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+160 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+160 }
and eax,0000FE00 { 65024 }
cmp eax,0000FE00 { 65024 }
jne goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
mov bl,01 { 1 }
mov esi,00000006 { 6 }
mov [ebp-24],bl
goto5:
mov edx,00000001 { 1 }
mov ecx,00000003 { 3 }
mov [ebp-10],edx
movecx08:
mov [ebp+08],ecx
cmps0Fs:
cmp edi,0F { 15 }
ja goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
mov eax,ecx
sub eax,02 { 2 }
je gatego1//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1EB { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1EB }
sub eax,01 { 1 }
je gatego2//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1BB { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1BB }
sub eax,01 { 1 }
jne goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
cmp esi,01 { 1 }
ja goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
cmp [ebp-18],00000800 { 2048 }
ja goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
cmp [ebp-14],00000800 { 2048 }
ja goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
cmp edx,00000800 { 2048 }
goto4un2:
jna gatego3//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1FC { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1FC }
goto4:
pop edi
pop esi
mov eax,80070032 { -2147024846 }
pop ebx
mov ecx,[ebp-0C]
mov fs:[00000000],ecx { 0 }
mov esp,ebp
pop ebp
ret
gatego2:
cmp esi,00000800 { 2048 }
ja goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
test bl,bl
je gatew1//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1D9 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1D9 }
cmp [ebp-18],00004000 { 16384 }
ja goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
cmp [ebp-14],00004000 { 16384 }
jmp goto4un2//-2//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A3 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A3 }
gatew1:
cmp [ebp-18],00004000 { 16384 }
ja goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
cmp [ebp-14],00004000 { 16384 }
jmp gatew2//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1FA { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1FA }
gatego1:
cmp esi,00000800 { 2048 }
ja goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
cmp [ebp-18],00004000 { 16384 }
gatew2:
ja goto4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+1A5 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+1A5 }
gatego3:
mov eax,edi
xor ecx,ecx
imul eax,esi
mov edx,0000000C { 12 }
push 00//Dx11Demo_11.std::nothrow { (0) }
mul edx
seto cl
neg ecx
or ecx,eax
push ecx
call operX//"Dx11Demo_11.operator new[]"
add esp,08 { 8 }
mov [ebp-38],eax
mov [ebp-04],00000000 { 0 }
test eax,eax
jne gatew3//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+243 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+243 }
pop edi
pop esi
mov eax,8007000E { -2147024882 }
pop ebx
mov ecx,[ebp-0C]
mov fs:[00000000],ecx { 0 }
mov esp,ebp
pop ebp
ret
gatew3:
push eax
mov edx,[ebp-14]
lea eax,[ebp-28]
push eax
mov ecx,[ebp-18]
lea eax,[ebp-2C]
push eax
lea eax,[ebp-30]
mov [ebp-28],00000000 { 0 }
push eax
lea eax,[ebp-34]
mov [ebp-34],00000000 { 0 }
push eax
push [ebp+0C]
mov [ebp-30],00000000 { 0 }
push [ebp+10]
mov [ebp-2C],00000000 { 0 }
push 00 { 0 }
push [ebp-20]
push esi
push edi
push [ebp-10]
call FillInitDataDBVM//FillInitDataDBVM//"Dx11Demo_11.`anonymous namespace'::FillInitData"
add esp,30 { 48 }
mov [ebp-1C],eax
test eax,eax
js ErrorWowo//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+3BC { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+3BC }
push [ebp+30]
mov edx,[ebp+08]
mov eax,edi
push 00 { 0 }
push [ebp-38]
sub eax,[ebp-28]
push [ebp-24]
push ecx
push 00 { 0 }
push ecx
push 08 { 8 }
push ecx
push [ebp-20]
mov ecx,[ebp-3C]
push esi
push eax
push [ebp-2C]
push [ebp-30]
push [ebp-34]
call CreateD3DResourcesDBVM//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"
add esp,3C { 60 }
mov [ebp-1C],eax
test eax,eax
jns ErrorWowo//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+3BC { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+3BC }
cmp edi,01 { 1 }
jbe ErrorWowo//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+3BC { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+3BC }
mov ecx,[ebp-3C]
push ecx
mov eax,[ecx]
call dword ptr [eax+00000094]
cmp eax,00009100 { 37120 }
je gotoa1//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+317 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+317 }
cmp eax,00009200 { 37376 }
je gotoa1//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+317 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+317 }
mov ebx,[ebp+08]
cmp eax,00009300 { 37632 }
je gotoa2//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+310 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+310 }
mov eax,00002000 { 8192 }
mov ecx,00000800 { 2048 }
jmp gotoa3//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+32F { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+32F }
gotoa2:
mov eax,00001000 { 4096 }
jmp gotoa4//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+32A { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+32A }
gotoa1:
test bl,bl
mov ebx,[ebp+08]
je gotoa5//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+325 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+325 }
mov eax,00000200 { 512 }
jmp gotoa6//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+335 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+335 }
gotoa5:
mov eax,00000800 { 2048 }
gotoa4:
mov ecx,00000100 { 256 }
gotoa3:
cmp ebx,04 { 4 }
cmove eax,ecx
gotoa6:
push [ebp-38]
mov edx,[ebp-14]
lea ecx,[ebp-28]
push ecx
lea ecx,[ebp-2C]
push ecx
lea ecx,[ebp-30]
push ecx
lea ecx,[ebp-34]
push ecx
push [ebp+0C]
mov ecx,[ebp-18]
push [ebp+10]
push eax
push [ebp-20]
push esi
push edi
push [ebp-10]
call FillInitDataDBVM//"Dx11Demo_11.`anonymous namespace'::FillInitData"
add esp,30 { 48 }
mov [ebp-1C],eax
test eax,eax
js ErrorWowo//"Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS"+3BC { -&gt;Dx11Demo_11.`anonymous namespace'::CreateTextureFromDDS+3BC }
push [ebp+30]
sub edi,[ebp-28]
mov edx,ebx
push 00 { 0 }
push [ebp-38]
push [ebp-24]
push ecx
push 00 { 0 }
push ecx
push 08 { 8 }
push ecx
push [ebp-20]
mov ecx,[ebp-3C]
push esi
push edi
push [ebp-2C]
push [ebp-30]
push [ebp-34]
call CreateD3DResourcesDBVM//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"
add esp,3C { 60 }
mov esi,eax
push [ebp-38]
call ucrtbase.free//"Dx11Demo_11.operator delete[]"
add esp,04 { 4 }
mov eax,esi
pop edi
pop esi
pop ebx
mov ecx,[ebp-0C]
mov fs:[00000000],ecx { 0 }
mov esp,ebp
pop ebp
ret
ErrorWowo:
push [ebp-38]
mov esi,[ebp-1C]
call ucrtbase.free//"Dx11Demo_11.operator delete[]"
mov ecx,[ebp-0C]
add esp,04 { 4 }
mov eax,esi
mov fs:[00000000],ecx { 0 }
pop edi
pop esi
pop ebx
mov esp,ebp
pop ebp
ret

 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>903</ID>
              <Description>"GraphicsClassX::DXBitmapClassInitialize::CreateDDSTextureFromFileExDBVMX::CreateTextureFromDDS::CreateTextureFromDDS:NameSpaceBitsPixelX"</Description>
              <LastState Activated="1"/>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

label(xorAC)
label(nomalX)
label(endX)
NameSpaceBitsPixelX:
dec ecx
cmp ecx,72 { 114 }
ja xorAC//"Dx11Demo_11.`anonymous namespace'::BitsPerPixel"+50 { -&gt;Dx11Demo_11.`anonymous namespace'::BitsPerPixel+50 }
movzx eax,byte ptr [ecx+endX]
jmp nomalX//dword ptr [eax*4+endX]
mov eax,00000080 { 128 }
ret
mov eax,00000060 { 96 }
ret
mov eax,00000040 { 64 }
ret
nomalX:
mov eax,00000020 { 32 }
ret
mov eax,00000018 { 24 }
ret
mov eax,00000010 { 16 }
ret
mov eax,0000000C { 12 }
ret
mov eax,00000001 { 1 }
ret
mov eax,00000004 { 4 }
ret
mov eax,00000008 { 8 }
ret
xorAC:
xor eax,eax
ret
endX:
db 00 00 00 00 01 01 01 01 02 02 02 02 02 02 02 02 02 02 02 02 02 02 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 04 04 04 04 04 04 04 04 04 04 04 04 05 05 05 05 05 05 06 03 03 03 07 07 07 05 05 05 05 05 05 07 07 07 05 05 05 04 04 03 03 03 03 03 03 03 05 05 05 05 05 05 03 03 02 08 09 09 08 03 02 02 08 05 05 05 04 04 CC 55 8B EC 53 8B 5D 08 56 57 8B FA 8B F1 8D 43 BC 32 C9 33 D2 83 F8 29 77 7A 0F B6 80 5C 24 40 00 FF 24 85 40 24 40 00 BB 08 00 00 00 EB 05 BB 10 00 00 00 33 C9 85 F6 74 10 8D 46 03 B9 01 00 00 00
 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>904</ID>
              <Description>"GraphicsClassX::DXBitmapClassInitialize::CreateDDSTextureFromFileExDBVMX::CreateTextureFromDDS::CreateTextureFromDDS:GetDXGIFormatDBVM"</Description>
              <LastState Activated="1"/>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

label(Null2000)
label(Code10add7C00)
label(xoraccret)
label(Endadd00FF0000)
label(Endadd3FF00000)
label(Endadd0000F800)
label(Endadd00000F00)
label(31gate)
label(Null00080000)

label(zeroacc1c)
label(cmpsaccXW)
label(cmpsaccXW2)
label(02cmps)
label(cmps10gate)
label(cmpsffX)
label(04gate)
label(cmps20)
label(endXAW)
label(DXT3X)
GetDXGIFormatDBVM:
mov eax,[ecx+04]
test al,40 { 64 }
je Null2000//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+1BD { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+1BD }
mov eax,[ecx+0C]
cmp eax,10 { 16 }
je Code10add7C00//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+126 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+126 }
cmp eax,20 { 32 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,[ecx+10]
cmp eax,000000FF { 255 }
jne Endadd00FF0000//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+57 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+57 }
cmp [ecx+14],0000FF00 { 65280 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp [ecx+18],00FF0000 //Dx11Demo_11.exe+BF0000 { 00FF0000 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp [ecx+1C],FF000000 { -16777216 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,0000001C { 28 }
ret
Endadd00FF0000:
cmp eax,00FF0000//Dx11Demo_11.exe+BF0000 { 00FF0000 }
jne Endadd3FF00000//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+97 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+97 }
cmp [ecx+14],0000FF00 { 65280 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp [ecx+18],000000FF { 255 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp [ecx+1C],FF000000 { -16777216 }
jne zeroacc1c//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+87 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+87 }
mov eax,00000057 { 87 }
ret
zeroacc1c:
cmp dword ptr [ecx+1C],00 { 0 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,00000058 { 88 }
ret
Endadd3FF00000:
cmp eax,3FF00000 { 1.88 }
jne cmpsaccXW//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+CB { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+CB }
cmp [ecx+14],000FFC00 { 1047552 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp [ecx+18],000003FF { 1023 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp [ecx+1C],C0000000 { -2.00 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,00000018 { 24 }
ret
cmpsaccXW:
cmp eax,0000FFFF { 65535 }
jne cmpsaccXW2//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+F9 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+F9 }
cmp [ecx+14],FFFF0000 { -65536 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+18],00 { 0 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+1C],00 { 0 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,00000023 { 35 }
ret
cmpsaccXW2:
cmp eax,-01 { 255 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+14],00 { 0 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+18],00 { 0 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+1C],00 { 0 }
jne xoraccret//xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,00000029 { 41 }
ret
Code10add7C00:
mov eax,[ecx+10]
cmp eax,00007C00 { 31744 }
jne Endadd0000F800//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+15A { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+15A }
cmp [ecx+14],000003E0 { 992 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+18],1F { 31 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp [ecx+1C],00008000 { 32768 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,00000056 { 86 }
ret
Endadd0000F800:
cmp eax,0000F800 { 63488 }
jne Endadd00000F00//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+188 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+188 }
cmp [ecx+14],000007E0 { 2016 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+18],1F { 31 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+1C],00 { 0 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,00000055 { 85 }
ret
Endadd00000F00:
cmp eax,00000F00 { 3840 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp [ecx+14],000000F0 { 240 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+18],0F { 15 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp [ecx+1C],0000F000 { 61440 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,00000073 { 115 }
ret
Null2000:
test eax,00020000 { (44) }
je 02cmps//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+266 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+266 }
mov eax,[ecx+0C]
cmp eax,08 { 8 }
jne cmps10gate//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+1FD { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+1FD }
cmp [ecx+10],000000FF { 255 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+14],00 { 0 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+18],00 { 0 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+1C],00 { 0 }
jne 31gate//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+253 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+253 }
mov eax,0000003D { 61 }
ret
cmps10gate:
cmp eax,10 { 16 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,[ecx+10]
cmp eax,0000FFFF { 65535 }
jne cmpsffX//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+234 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+234 }
cmp dword ptr [ecx+14],00 { 0 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+18],00 { 0 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+1C],00 { 0 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,00000038 { 56 }
ret
cmpsffX:
cmp eax,000000FF { 255 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+14],00 { 0 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+18],00 { 0 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
31gate:
cmp [ecx+1C],0000FF00 { 65280 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,00000031 { 49 }
ret
02cmps:
test al,02 { 2 }
je Null00080000//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+27A { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+27A }
cmp dword ptr [ecx+0C],08 { 8 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,00000041 { 65 }
ret
Null00080000:
test eax,00080000 { 524288 }
je 04gate//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+333 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+333 }
mov eax,[ecx+0C]
cmp eax,10 { 16 }
jne cmps20//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+2C1 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+2C1 }
cmp [ecx+10],000000FF { 255 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp [ecx+14],0000FF00 { 65280 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+18],00 { 0 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+1C],00 { 0 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,00000033 { 51 }
ret
cmps20:
cmp eax,20 { 32 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,[ecx+10]
cmp eax,000000FF { 255 }
jne endXAW//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+301 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+301 }
cmp [ecx+14],0000FF00 { 65280 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp [ecx+18],00FF0000//Dx11Demo_11.exe+BF0000 { 00FF0000 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp [ecx+1C],FF000000 { -16777216 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,0000001F { 31 }
ret
endXAW:
cmp eax,0000FFFF { 65535 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp [ecx+14],FFFF0000 { -65536 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+18],00 { 0 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
cmp dword ptr [ecx+1C],00 { 0 }
jne xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,00000025 { 37 }
ret
04gate:
test al,04 { 4 }
je xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
mov eax,[ecx+08]
cmp eax,31545844 { "DXT1" }
jne DXT3X// "Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+34B { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+34B }
mov eax,00000047 { 71 }
ret

label(4Agate)
label(4Dgate)
label(50gate)
label(endgate)
label(53gate)
label(RGBGgate)
DXT3X:
cmp eax,33545844 { "DXT3" }
je 4Agate//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+42E { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+42E }
cmp eax,35545844 { "DXT5" }
je 4Dgate//4Dgate"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+428 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+428 }
cmp eax,32545844 { "DXT2" }
je 4Agate//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+42E { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+42E }
cmp eax,34545844 { "DXT4" }
je 4Dgate//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+428 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+428 }
cmp eax,31495441 { "ATI1" }
je 50gate//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+422 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+422 }
cmp eax,55344342 { "BC4U" }
je 50gate//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+422 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+422 }
cmp eax,53344342 { "BC4S" }
jne endgate//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+39A { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+39A }
mov eax,00000051 { 81 }
ret
endgate:
cmp eax,32495441 { "ATI2" }
je 53gate//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+41C { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+41C }
cmp eax,55354342 { "BC5U" }
je 53gate//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+41C { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+41C }
cmp eax,53354342 { "BC5S" }
jne RGBGgate//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+3B5 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+3B5 }
mov eax,00000054 { 84 }
ret

label(RGBGgate2)
label(YUYXGate)
label(un24ac)
label(endEX)

RGBGgate:
cmp eax,47424752 { "RGBG" }
jne RGBGgate2//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+3C2 { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+3C2 }
mov eax,00000044 { 68 }
ret
RGBGgate2:
cmp eax,42475247 { "GRGB" }
jne YUYXGate//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+3CF { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+3CF }
mov eax,00000045 { 69 }
ret
YUYXGate:
cmp eax,32595559 { "YUY2" }
jne un24ac//"Dx11Demo_11.`anonymous namespace'::GetDXGIFormat"+3DC { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+3DC }
mov eax,0000006B { 107 }
ret
un24ac:
add eax,-24 { 220 }
cmp eax,50 { 80 }
ja xoraccret { -&gt;Dx11Demo_11.`anonymous namespace'::GetDXGIFormat+434 }
movzx eax,byte ptr [eax+endEX+24]
jmp dword ptr [eax*4+endEX]
mov eax,0000000B { 11 }
ret
mov eax,0000000D { 13 }
ret
mov eax,00000036 { 54 }
ret
mov eax,00000022 { 34 }
ret
mov eax,0000000A { 10 }
ret
mov eax,00000010 { 16 }
ret
mov eax,00000002 { 2 }
ret
53gate:
mov eax,00000053 { 83 }
ret
50gate:
mov eax,00000050 { 80 }
ret
4Dgate:
mov eax,0000004D { 77 }
ret
4Agate:
mov eax,0000004A { 74 }
ret
xoraccret:
xor eax,eax
ret
nop
endEX:
nop

 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>905</ID>
              <Description>"GraphicsClassX::DXBitmapClassInitialize::CreateDDSTextureFromFileExDBVMX::CreateTextureFromDDS::CreateTextureFromDDS:FillInitDataDBVM"</Description>
              <LastState Activated="1"/>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

label(nullpointer)
label(xorPointer)
label(incAcacc)
label(un04)
label(cmps0X)
label(incX24)
label(MulAcc)
label(un1cAcc)
label(End2Exit)
label(cmpsinc0c) //whileloop
FillInitDataDBVM:
push ebp
mov ebp,esp
sub esp,28 { 40 }
push ebx
push esi
mov esi,[ebp+20]
mov ebx,ecx
mov [ebp-24],edx
mov [ebp-28],ebx
test esi,esi
je nullpointer//"Dx11Demo_11.`anonymous namespace'::FillInitData"+1A6 { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+1A6 }
cmp dword ptr [ebp+34],00 { 0 }
je nullpointer//"Dx11Demo_11.`anonymous namespace'::FillInitData"+1A6 { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+1A6 }
mov eax,[ebp+30]
push edi
mov [ebp-0C],00000000 { 0 }
mov [ebp-1C],00000000 { 0 }
mov [eax],00000000 { 0 }
mov eax,[ebp+24]
mov [eax],00000000 { 0 }
mov eax,[ebp+28]
mov [eax],00000000 { 0 }
mov eax,[ebp+2C]
mov [eax],00000000 { 0 }
mov eax,[ebp+1C]
add eax,esi
xor esi,esi
mov [ebp-20],eax
xor eax,eax
mov [ebp-14],eax
mov [ebp-18],esi
cmp [ebp+10],eax
jbe xorPointer//"Dx11Demo_11.`anonymous namespace'::FillInitData"+18F { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+18F }
mov edi,[ebp+18]
cmpsinc0c:
cmp dword ptr [ebp+0C],00 { 0 }
mov ecx,ebx
mov ebx,[ebp+08]
mov [ebp-08],ecx
mov [ebp-04],edx
mov [ebp-10],00000000 { 0 }
jbe incAcacc//"Dx11Demo_11.`anonymous namespace'::FillInitData"+16F { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+16F }
mov esi,[ebp+34]
lea eax,[eax+eax*2]
lea esi,[esi+eax*4]
add esi,08 { 8 }
nop 2
cmpsun1c:
push ecx
lea eax,[ebp-1C]
push eax
lea eax,[ebp-0C]
push eax
push [ebp+14]
call GetSurfaceInfoDBVM//00402350//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"////////////
mov edx,[ebp-08]
add esp,10 { 16 }
cmp dword ptr [ebp+0C],01 { 1 }
jna un04//"Dx11Demo_11.`anonymous namespace'::FillInitData"+E0 { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+E0 }
test edi,edi
je un04//"Dx11Demo_11.`anonymous namespace'::FillInitData"+E0 { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+E0 }
cmp edx,edi
ja cmps0X//"Dx11Demo_11.`anonymous namespace'::FillInitData"+D0 { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+D0 }
mov eax,[ebp-04]
cmp eax,edi
ja cmps0X//"Dx11Demo_11.`anonymous namespace'::FillInitData"+D0 { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+D0 }
cmp ebx,edi
jna incX24//"Dx11Demo_11.`anonymous namespace'::FillInitData"+E3 { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+E3 }
cmps0X:
cmp dword ptr [ebp-18],00 { 0 }
mov ecx,[ebp+20]
jne MulAcc//"Dx11Demo_11.`anonymous namespace'::FillInitData"+10E { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+10E }
mov eax,[ebp+30]
inc [eax]
jmp MulAcc//"Dx11Demo_11.`anonymous namespace'::FillInitData"+10E { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+10E }
un04:
mov eax,[ebp-04]
incX24:
mov ecx,[ebp+24]
cmp dword ptr [ecx],00 { 0 }
jne un1cAcc//"Dx11Demo_11.`anonymous namespace'::FillInitData"+F7 { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+F7 }
mov [ecx],edx
mov ecx,[ebp+28]
mov [ecx],eax
mov eax,[ebp+2C]
mov [eax],ebx
un1cAcc:
mov eax,[ebp-1C]
mov ecx,[ebp+20]
inc [ebp-14]
mov [esi-04],eax
mov eax,[ebp-0C]
mov [esi-08],ecx
mov [esi],eax
add esi,0C { 12 }
MulAcc:
mov eax,ebx
imul eax,[ebp-0C]
add ecx,eax
mov [ebp+20],ecx
cmp ecx,[ebp-20]
ja End2Exit//"Dx11Demo_11.`anonymous namespace'::FillInitData"+183 { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+183 }
inc [ebp-10]
mov ecx,edx
shr ecx,1
mov eax,00000001 { 1 }
cmp edx,02 { 2 }
cmovae eax,ecx
mov ecx,[ebp-04]
shr ecx,1
cmp dword ptr [ebp-04],02 { 2 }
mov [ebp-08],eax
mov eax,00000001 { 1 }
cmovae eax,ecx
mov ecx,ebx
shr ecx,1
mov edx,eax
mov [ebp-04],eax
cmp ebx,02 { 2 }
mov eax,00000001 { 1 }
cmovae eax,ecx
mov ecx,[ebp-08]
mov ebx,eax
mov eax,[ebp-10]
cmp eax,[ebp+0C]
jb cmpsun1c//"Dx11Demo_11.`anonymous namespace'::FillInitData"+A0 { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+A0 }
mov eax,[ebp-14]
mov esi,[ebp-18]
incAcacc:
inc esi
mov [ebp-18],esi
cmp esi,[ebp+10]
jae xorPointer//"Dx11Demo_11.`anonymous namespace'::FillInitData"+18F { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+18F }
mov edx,[ebp-24]
mov ebx,[ebp-28]
jmp cmpsinc0c//"Dx11Demo_11.`anonymous namespace'::FillInitData"+76 { -&gt;Dx11Demo_11.`anonymous namespace'::FillInitData+76 }
End2Exit:
pop edi
pop esi
mov eax,80070026 { -2147024858 }
pop ebx
mov esp,ebp
pop ebp
ret
xorPointer:
xor ecx,ecx
cmp ecx,eax
pop edi
sbb eax,eax
and eax,7FFFBFFB { 2147467259 }
pop esi
add eax,80004005 { -2147467259 }
pop ebx
mov esp,ebp
pop ebp
ret
nullpointer:
pop esi
mov eax,80004003 { -2147467261 }
pop ebx
mov esp,ebp
pop ebp
ret

 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>906</ID>
                  <Description>"GraphicsClassX::DXBitmapClassInitialize::CreateDDSTextureFromFileExDBVMX::CreateTextureFromDDS::CreateTextureFromDDS:FillInitDataDBVM::FillInitDataDBVM:GetSurfaceInfoDBVM"</Description>
                  <LastState Activated="1"/>
                  <Color>FF00FF</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

label(goto1)
label(goto2)
label(goto3)
label(goto4)
label(goto5)
label(goto6)
label(goto7)
label(goto8)
label(goto9)
label(goto10)
label(goto11)
GetSurfaceInfoDBVM:
push ebp
mov ebp,esp
push ebx
mov ebx,[ebp+08]
push esi
push edi
mov edi,edx
mov esi,ecx
lea eax,[ebx-44]
xor cl,cl
xor edx,edx
cmp eax,29 { 41 }
ja goto1//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"+93 { -&gt;Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo+93 }
movzx eax,byte ptr [eax+GetSurfaceInfoDBVM+600]
jmp goto1//004023E3//dword ptr [eax*4+goto12]
mov ebx,00000008 { 8 }
jmp goto2//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"+33 { -&gt;Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo+33 }
mov ebx,00000010 { 16 }
goto2:
xor ecx,ecx
test esi,esi
je goto3//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"+49 { -&gt;Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo+49 }
lea eax,[esi+03]
mov ecx,00000001 { 1 }
shr eax,02 { 2 }
cmp eax,ecx
cmova ecx,eax
goto3:
xor edx,edx
test edi,edi
je goto4//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"+5F { -&gt;Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo+5F }
lea eax,[edi+03]
mov edx,00000001 { 1 }
shr eax,02 { 2 }
cmp eax,edx
cmova edx,eax
goto4:
imul ecx,ebx
imul edx,ecx
jmp goto5//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"+D6 { -&gt;Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo+D6 }
lea ecx,[esi+01]
mov eax,00000004 { 4 }
shr ecx,1
imul ecx,eax
jmp goto6//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"+D1 { -&gt;Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo+D1 }
lea ecx,[esi+01]
mov eax,00000008 { 8 }
shr ecx,1
imul ecx,eax
jmp goto6//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"+D1 { -&gt;Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo+D1 }
mov edx,00000002 { 2 }
jmp goto7//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"+91 { -&gt;Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo+91 }
mov edx,00000004 { 4 }
goto7:
mov cl,01 { 1 }
goto1:
cmp ebx,6E { 110 }
jne goto8//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"+A6 { -&gt;Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo+A6 }
lea ecx,[esi+03]
and ecx,-04 { 252 }
lea edx,[edi+edi]
imul edx,ecx
jmp goto5//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"+D6 { -&gt;Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo+D6 }
goto8:
test cl,cl
je goto9//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"+BF { -&gt;Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo+BF }
lea ecx,[esi+01]
shr ecx,1
imul ecx,edx
mov eax,ecx
imul eax,edi
mov edx,eax
shr edx,1
add edx,eax
jmp goto5//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"+D6 { -&gt;Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo+D6 }
goto9:
mov ecx,ebx
call NameSpaceBitsPixelX//"Dx11Demo_11.`anonymous namespace'::BitsPerPixel"
mov ecx,eax
imul ecx,esi
add ecx,07 { 7 }
shr ecx,03 { 3 }
goto6:
mov edx,ecx
imul edx,edi
goto5:
mov eax,[ebp+0C]
pop edi
pop esi
pop ebx
test eax,eax
je goto10//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"+E2 { -&gt;Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo+E2 }
mov [eax],edx
goto10:
mov eax,[ebp+10]
test eax,eax
je goto11//"Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo"+EB { -&gt;Dx11Demo_11.`anonymous namespace'::GetSurfaceInfo+EB }
mov [eax],ecx
goto11:
pop ebp
ret
db 0F 1F 00
GetSurfaceInfoDBVM+600:
db 00 00 01 01 01 02 02 02 02 02 02 01 01 01 02 02 02 06 06 06 06 06 06 06 06 06 02 02 02 02 02 02 02 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>907</ID>
              <Description>"GraphicsClassX::DXBitmapClassInitialize::CreateDDSTextureFromFileExDBVMX::CreateTextureFromDDS::CreateTextureFromDDS:CreateD3DResourcesDBVM"</Description>
              <LastState Activated="1"/>
              <Color>FF0000</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

label(goto1)
label(goto2)
label(goto3)
label(goto4)
label(goto5)
label(goto6)
label(goto7)
label(goto8)
label(goto9)
label(goto10)
label(goto11)
label(goto12)
label(goto13)
label(goto14)
label(goto15)
label(goto16)

CreateD3DResourcesDBVM:
push ebp
mov ebp,esp
and esp,-08 { 248 }
sub esp,4C { 76 }
push ebx
push esi
push edi
mov edi,ecx
test edi,edi
jne goto1//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+1E { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+1E }
mov eax,80004003 { -2147467261 }
pop edi
pop esi
pop ebx
mov esp,ebp
pop ebp
ret
goto1:
mov esi,80004005 { -2147467259 }
sub edx,02 { 2 }
je goto2//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+253 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+253 }
sub edx,01 { 1 }
je goto3//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+10C { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+10C }
sub edx,01 { 1 }
jne goto4//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+32D { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+32D }
mov eax,[ebp+08]
lea ecx,[esp+0C]
mov ebx,[ebp+14]
mov [esp+2C],eax
mov eax,[ebp+0C]
mov [esp+30],eax
mov eax,[ebp+10]
mov [esp+34],eax
mov eax,[ebp+1C]
mov [esp+3C],eax
mov eax,[ebp+24]
mov [esp+44],eax
mov eax,[ebp+2C]
push ecx
push [ebp+38]
and eax,-05 { 251 }
mov [esp+40],ebx
mov [esp+54],eax
lea ecx,[esp+34]
mov eax,[edi]
push ecx
push edi
mov [esp+50],edx
mov [esp+58],edx
mov [esp+1C],edx
call dword ptr [eax+18]

mov esi,eax
test esi,esi
js goto4//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+32D { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+32D }
mov ecx,[esp+0C]
test ecx,ecx
je goto4//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+32D { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+32D }
mov edx,[ebp+40]
test edx,edx
je goto5//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+315 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+315 }
mov eax,[ebp+1C]
xorps xmm0,xmm0
mov [esp+14],eax
mov eax,[esp+38]
mov [esp+1C],00000000 { 0 }
movlpd [esp+24],xmm0
mov [esp+18],00000008 { 8 }
goto15:
or esi,-01 { 255 }
test ebx,ebx
cmove eax,esi
goto14:
mov [esp+20],eax
push edx
goto11:
mov eax,[edi]
lea edx,[esp+18]
push edx
push ecx
push edi
call dword ptr [eax+1C]
mov esi,eax
test esi,esi
jns goto6//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+311 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+311 }
mov eax,[esp+0C]
push eax
mov ecx,[eax]
call dword ptr [ecx+08]
mov eax,esi
pop edi
pop esi
pop ebx
mov esp,ebp
pop ebp
ret
goto3:
cmp byte ptr [ebp+34],00 { 0 }
mov eax,[ebp+08]
mov ebx,[ebp+18]
mov [esp+2C],eax
mov eax,[ebp+0C]
mov [esp+30],eax
mov eax,[ebp+14]
mov [esp+34],eax
mov eax,[ebp+1C]
mov [esp+3C],eax
mov eax,[ebp+24]
mov [esp+4C],eax
mov eax,[ebp+2C]
mov [esp+38],ebx

mov [esp+40],00000001 { 1 }
mov [esp+44],00000000 { 0 }
mov [esp+48],00000000 { 0 }
mov [esp+50],00000000 { 0 }
je goto7//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+164 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+164 }
or eax,04 { 4 }
jmp goto8//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+167 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+167 }
goto7:
and eax,-05 { 251 }
goto8:
lea ecx,[esp+0C]
mov [esp+54],eax
mov eax,[edi]
push ecx
push [ebp+38]
lea ecx,[esp+34]
mov [esp+14],00000000 { 0 }
push ecx
push edi
call dword ptr [eax+14]
mov esi,eax
test esi,esi
js goto4//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+32D { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+32D }
mov ecx,[esp+0C]
test ecx,ecx
je goto4//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+32D { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+32D }
cmp dword ptr [ebp+40],00 { 0 }
je goto5//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+315 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+315 }
mov eax,[ebp+1C]
xorps xmm0,xmm0
or edx,-01 { 255 }
mov [esp+14],eax
cmp byte ptr [ebp+34],00 { 0 }
mov eax,[esp+34]
mov [esp+1C],00000000 { 0 }
movlpd [esp+24],xmm0
je goto9//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+214 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+214 }
cmp ebx,06 { 6 }
jna goto10//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+1F9 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+1F9 }
cmp dword ptr [ebp+14],00 { 0 }
push [ebp+40]
cmove eax,edx
mov [esp+1C],0000000A { 10 }
mov [esp+24],eax
mov eax,AAAAAAAB { -1431655765 }
mul ebx
shr edx,02 { 2 }
mov [esp+2C],edx
jmp goto11//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+E3 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+E3 }
goto10:
cmp dword ptr [ebp+14],00 { 0 }
push [ebp+40]
cmove eax,edx
mov [esp+1C],00000009 { 9 }
mov [esp+24],eax
jmp goto11//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+E3 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+E3 }
goto9:
cmp ebx,01 { 1 }
jna goto12//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+238 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+238 }
cmp dword ptr [ebp+14],00 { 0 }
push [ebp+40]
cmove eax,edx
mov [esp+1C],00000005 { 5 }
mov [esp+2C],ebx
mov [esp+24],eax
jmp goto11//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+E3 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+E3 }
goto12:
cmp dword ptr [ebp+14],00 { 0 }
push [ebp+40]
cmove eax,edx
mov [esp+1C],00000004 { 4 }
mov [esp+24],eax
jmp goto11//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+E3 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+E3 }
goto2:
mov eax,[ebp+08]
lea ecx,[esp+0C]
mov ebx,[ebp+14]
mov [esp+2C],eax
mov eax,[ebp+18]
mov [esp+34],eax
mov eax,[ebp+1C]
mov [esp+38],eax
mov eax,[ebp+24]
mov [esp+40],eax
mov eax,[ebp+2C]
push ecx
push [ebp+38]
and eax,-05 { 251 }
mov [esp+38],ebx
mov [esp+50],eax
lea ecx,[esp+34]
mov eax,[edi]
push ecx
push edi
mov [esp+4C],00000000 { 0 }
mov [esp+54],00000000 { 0 }
mov [esp+1C],00000000 { 0 }
call dword ptr [eax+10]
mov esi,eax
test esi,esi
js goto4//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+32D { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+32D }
mov ecx,[esp+0C]
test ecx,ecx
je goto4//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+32D { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+32D }
mov edx,[ebp+40]
test edx,edx
je goto5//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+315 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+315 }
mov eax,[ebp+1C]
xorps xmm0,xmm0
mov esi,[ebp+18]
mov [esp+14],eax
mov eax,[esp+30]
mov [esp+1C],00000000 { 0 }
movlpd [esp+24],xmm0
cmp esi,01 { 1 }
jna goto13//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+304 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+304 }
test ebx,ebx
mov [esp+10],FFFFFFFF { -1 }
mov [esp+18],00000003 { 3 }
cmove eax,[esp+10]
mov [esp+28],esi
jmp goto14//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+DE { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+DE }
goto13:
mov [esp+18],00000002 { 2 }
jmp goto15//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+D6 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+D6 }
goto6:
mov ecx,[esp+0C]
goto5:
mov eax,[ebp+3C]
test eax,eax
je goto16//"Dx11Demo_11.`anonymous namespace'::CreateD3DResources"+327 { -&gt;Dx11Demo_11.`anonymous namespace'::CreateD3DResources+327 }
mov [eax],ecx
mov eax,esi
pop edi
pop esi
pop ebx
mov esp,ebp
pop ebp
ret
goto16:
mov eax,[ecx]
push ecx
call dword ptr [eax+08]
goto4:
pop edi
mov eax,esi
pop esi
pop ebx
mov esp,ebp
pop ebp
ret
int 3

 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>908</ID>
      <Description>"메모리 셋api"</Description>
      <LastState Activated="1"/>
      <Color>008000</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
label(goto1)
label(goto2)
memsetapi:
push ebp
mov ebp,esp
sub esp,48
push 44
push 00
lea eax,[ebp-48]
push eax
call [IAT+34]//ntdll.memset
add esp,0C
lea ecx,[ebp-48]
push ecx
call [IAT+38]//kernel32.GetStartupInfoW
mov edx,[ebp-1C]
and edx,01
je goto1
movzx eax,wordptr[ebp-18]
mov [ebp-04],eax
jmp goto2
goto1:
mov [ebp-04],0000000A
goto2:
mov ax,[ebp-04]
mov esp,ebp
pop ebp
ret



 
 
[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>909</ID>
      <Description>"MainAPI =병렬처리"</Description>
      <LastState Activated="1"/>
      <Color>00FF00</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
LoginMain:
push ebp
mov ebp,esp
sub esp,08
call memsetapi
movzx eax,ax
mov [ebp-04],eax
mov [ebp-08],eax
mov ecx,[ebp-04]
push ecx
mov edx,[ebp-08]
push edx
push 00
push 00400000//header
call LoginGui
mov esp,ebp
pop ebp
ret
 
 
[DISABLE]

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>910</ID>
          <Description>"SWitch"</Description>
          <LastState Activated="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
label(xors)//초기화
label(Post)//포스트
label(UsersBeginePaint)//처음 그리기
label(GetSystem)//시스템으로 가다
label(GetSystem2)
label(EndX)//마지막

labeL(LgoAPi)
label(boxApis)
label(mouseX)




Switch:
cmp [Msize-4],0
jne mouseX
push ebp
mov ebp,esp
sub esp,00000130 { 304 }
push ebx
push esi
push edi
lea edi,[ebp-70]
mov ecx,0000001C { 28 }
mov eax,CCCCCCCC { -858993460 }
repe stosd
mov eax,[ebp+0C]
mov [ebp-00000130],eax
//cmp dword ptr [ebp-00000130],200 { 15 }
//je mouseX//dllgotosgui.WndProc5+59
cmp dword ptr [ebp-00000130],111 { 1 }
je LgoAPi
cmp dword ptr [ebp-00000130],01 { 1 }
je xors
cmp dword ptr [ebp-00000130],02 { 2 }
je Post//dllgotosgui.WndProc5+C5
cmp dword ptr [ebp-00000130],0F { 15 }
je UsersBeginePaint//dllgotosgui.WndProc5+59

jmp GetSystem//GetSystem//dllgotosgui.WndProc5+DA
xors:
xor eax,eax
jmp EndX//인자를 초기화후 가준다.
UsersBeginePaint:
lea eax,[ebp-000000AC]
cmp [Msize-4],0
jne GetSystem2
mov [Msize-4],eax

lea eax,[ebp-50]//ebp-50
push eax
mov ecx,[ebp+8] //ebp-8
push ecx
call USER32.BeginPaint//win32u.NtUserBeginPaint //UsersBeginePaint//dword ptr [dllgotosgui._imp__BeginPaint] { -&amp;gt;-&amp;gt;win32u.NtUserBeginPaint } //UsersBeginePaint
mov [hdc],eax //-54
//mov eax,[ebp-54]
//mov [Msize-54],eax

xor eax,eax
jmp EndX
Post:
mov esi,esp
push 00 { 0 }
call USER32.PostQuitMessage
xor eax,eax
jmp EndX
GetSystem:
mov esi,esp
mov eax,[ebp+14]
push eax
mov ecx,[ebp+10]
push ecx
mov edx,[ebp+0C]
push edx
mov eax,[ebp+08]
push eax
call ntdll.NtdllDefWindowProc_W

EndX:
push edx
mov ecx,ebp
push eax
mov edx,2

pop eax
pop edx
pop edi
pop esi
pop ebx
add esp,00000130 { 304 }
mov esp,ebp
pop ebp
ret 0010 { 16 }


GetSystem2:
jmp GetSystem



LgoAPi:
mov eax,[ebp+10]
and eax,0000FFFF { 65535 }
movzx ecx,ax
mov [ebp-00000118],ecx
cmp dword ptr [ebp-00000118],00 { 0 }
//call boxa
je boxApis//
cmp dword ptr [ebp-00000118],01 { 1 }
je boxApis
jmp EndX//WindowsProject3D.WndProc+168
boxApis:

jmp EndX//WindowsProject3D.WndProc+168

label(dbvmr)
label(dbvmrDF)
label(keydatagate)
label(keydatagate2)
label(keydatagateB)
label(keydatagateB2)
mouseX:
mov ebx,[ebp+10]
test ebx,ebx
je dbvmr
mov EDI,[ebp+14]
test EDI,EDI
je dbvmr
cmp ebx,#258
je keydatagate
dbvmr:
cmp [basep],0
jne dbvmrDF
mov [basep],ebp
push #1
call sleep
ret

dbvmrDF:
push #1
call sleep
ret

label(Startcond)

keydatagate:
cmp [logoinSX],1
je Startcond
cmp [logoinSX],2
je keydatagateB
Startcond:
cmp edi,8
je keydatagate2
mov ebx,[KeyCount]
mov [KEYSave+ebx],edi
add [KeyCount],2//-4
push #1
call sleep
ret

keydatagate2:
cmp [KeyCount],0
je dbvmr
sub [KeyCount],2//-4
mov ebx,[KeyCount]
mov [KEYSave+ebx],0
push #1
call sleep
ret

keydatagateB:
cmp edi,8
je keydatagateB2
mov ebx,[KeyCount2]
mov [KEYSave2+ebx],edi
add [KeyCount2],2//-4
push #1
call sleep
ret


keydatagateB2:
cmp [KeyCount2],0
je dbvmr
sub [KeyCount2],2//-4
mov ebx,[KeyCount2]
mov [KEYSave2+ebx],0
push #1
call sleep
ret
[DISABLE]

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>911</ID>
              <Description>"CreateWindowsA"</Description>
              <LastState Activated="1"/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat











label(end)
label(endedx)
label(WhileX)
LoginGui:
push ebp
mov ebp,esp
sub esp,0000013C { 316 }
push ebx
push esi
push edi
lea edi,[ebp-7C]
mov ecx,0000001F { 31 }
mov eax,CCCCCCCC { -858993460 }
repe stosd
mov esi,esp
push 00 { 0 }
push 00 { 0 }
call combase.CoInitializeEx
push factory//이 부분 변경 해야 할 부분00402000//WindowsProjeddct5.dx2p_factory { (00452A58) } //팩토리 저장공간
push 00 { 0 }
push factoryGUID//WindowsProjeddct5._GUID_06152247_6f50_465a_9245_118bfd3b6007
push 00
call d2d1.D2D1CreateFactory
test eax,eax
je end//WindowsProjeddct5.WinMain+52
xor eax,eax
jmp endedx//WindowsProjeddct5.WinMain+1F6
end:
mov eax,[UnicodeDirect2DX1] { ("dx2_ts00") }
mov [ebp-48],eax
mov ecx,[UnicodeDirect2DX2] { ("2_ts00") }
mov [ebp-44],ecx
mov edx,[UnicodeDirect2DX3] { ("ts00") }
mov [ebp-40],edx
mov eax,00300030 // 본례는 다름
mov [ebp-3C],eax
mov cx,0
mov [ebp-38],cx
mov [ebp-24],00000000 { 0 }
mov [ebp-20],00000000 { 0 }
mov [ebp-10],00000000 { 0 }
mov esi,esp
push 00007F00 { 32512 }
push 00 { 0 }
call USER32.LoadCursorW
mov [ebp-14],eax
mov esi,esp
push 00007F00 { 32512 }
push 00 { 0 }
call USER32.LoadIconW
mov [ebp-18],eax
mov eax,[ebp+08]
mov [ebp-1C],eax
mov [ebp-28],Switch//WindowsProjeddct5.exe+110FF { (233) }
lea eax,[ebp-48]
mov [ebp-08],eax
mov [ebp-0C],00000000 { 0 }
mov [ebp-2C],00000003 { 3 }
mov esi,esp
lea eax,[ebp-2C]
push eax
call USER32.RegisterClassW
mov esi,esp
push 00 { 0 }
mov eax,[ebp+08]
push eax
push 00 { 0 }
push 00 { 0 }
push #600 { 540 }
push #800 { 840 }
push 00 { 0 }
push 00 { 0 }
push 00CF0000 { 13565952 }
push UnicodeDirect2DX1//WindowsProjeddct5.exe+18B60 { ("dx2_ts00") }
lea ecx,[ebp-48]
push ecx
push 00 { 0 }
call USER32.CreateWindowExW
mov [Handle],eax

mov [ebp-54],eax
mov esi,esp
mov eax,[ebp+14]
push eax
mov ecx,[ebp-54]
push ecx
call win32u.NtUserShowWindow
mov esi,esp
mov eax,[ebp-54]
push eax
call USER32.UpdateWindow
WhileX:
mov esi,esp
push 00 { 0 }
push 00 { 0 }
push 00 { 0 }
lea eax,[ebp-78]
push eax
call USER32.GetMessageW
test eax,eax
je endedx //cmpsx//WindowsProjeddct5.WinMain+1A3
mov esi,esp
lea eax,[ebp-78]
push eax
call USER32.TranslateMessage
mov esi,esp
lea eax,[ebp-78]
push eax
call USER32.DispatchMessageW
jmp WhileX//WindowsProjeddct5.WinMain+15E

cmpsx:
libACC:
mov eax,0//[00401000] { (0) }
mov ecx,[eax]
mov esi,esp
mov edx,0//[00401000]//[WindowsProjeddct5.dx2p_bitmap] { (0) }
push edx
mov eax,[ecx+08]
call eax
mov eax,[factory] { (00452A58) }
mov ecx,[eax]
mov esi,esp
mov edx,[factory] { (00452A58) }
push edx
mov eax,[ecx+08]
call eax
mov esi,esp
call combase.CoUninitialize

mov eax,[ebp-70]
endedx:
RET
push edx
mov ecx,ebp
push eax
mov edx,2
pop eax
pop edx
pop edi
pop esi
pop ebx
add esp,0000013C { 316 }
mov esp,ebp
pop ebp
ret 0010 { 16 }


[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>912</ID>
      <Description>"메인 팩토리 2 인자 생성기 or malloc4"</Description>
      <LastState Activated="1"/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat








ACMent1:
call malloc4

push ebp
mov ebp,esp
sub esp,000000E4 { 228 }
push ebx
push esi
push edi
lea edi,[ebp-24]
mov ecx,00000009 { 9 }
mov eax,CCCCCCCC { -858993460 }
repe stosd
mov eax,[ebp+0C]
mov [ebp-20],eax
mov eax,[ebp+10]
mov ecx,[eax]
mov edx,[eax+04]
mov [ebp-1C],ecx
mov [ebp-18],edx
movss xmm0,[ebp+14]
movss [ebp-14],xmm0
movss xmm0,[ebp+18]
movss [ebp-10],xmm0
mov eax,[ebp+1C]
mov [ebp-0C],eax
mov eax,[ebp+20]
mov [ebp-08],eax
mov ecx,00000007 { 7 }
lea esi,[ebp-20]
mov edi,[ebp+08]
repe movsd
mov eax,[ebp+08]
push edx
mov ecx,ebp
push eax
mov edx,1//[WindowsProjeddct5.D2D1::RenderTargetProperties+90] { (1) }
pop eax
pop edx
pop edi
pop esi
pop ebx
add esp,000000E4 { 228 }
mov esp,ebp
pop ebp
ret

ACMent2:
push ebp
mov ebp,esp
sub esp,000000CC { 204 }
push ebx
push esi
push edi
push ecx
lea edi,[ebp-0C]
mov ecx,00000003 { 3 }
mov eax,CCCCCCCC { -858993460 }
repe stosd
pop ecx
mov [ebp-08],ecx
mov esi,esp
mov eax,[ebp+10]
push eax
mov ecx,[ebp+0C]
push ecx
mov edx,[ebp+08]
push edx
mov eax,[ebp-08]
mov ecx,[eax]
mov edx,[ebp-08]
push edx
mov eax,[ecx+38]
call eax
pop edi
pop esi
pop ebx
add esp,000000CC { 204 }
mov esp,ebp
pop ebp
ret 000C { 12 }





factoryCreate:

push ebp
mov ebp,esp
sub esp,00000170 { 368 }
push ebx
push esi
push edi
lea edi,[ebp-000000B0]
mov ecx,2c { 0000002C }
mov eax,CCCCCCCC { -858993460 }
repe stosd



lea eax,[ebp-14]
push eax
mov ecx,[Handle]
push ecx
call USER32.GetClientRect

mov eax,[ebp-0c]
mov edx,[ebp-08]

mov [ebp-000000FC],eax
mov [ebp-000000F8],edx


mov ecx,[Handle]
mov [ebp-000000EC],ecx
mov [ebp-000000E8],eax
mov [ebp-000000E4],edx
mov [ebp-000000E0],0
mov [ebp-00000148],0
mov [ebp-00000144],0

push 00 { 0 }
push 00 { 0 }
push [Handle]
xorps xmm0,xmm0
movss [esp],xmm0
push [Handle]
xorps xmm0,xmm0
movss [esp],xmm0
lea eax,[ebp-00000148]
push eax
push 00 { 0 }
lea ecx,[ebp-0000016C]
push ecx //쓰레기 코드 청소

call ACMent1
add esp,1C { 28 }

push factory+4 { (0) } //factory+4

mov eax,[Handle]
mov [ebp-10],eax
lea edx,[ebp-10]
mov [edx+c],0
mov [edx+10],0
push edx
lea edx,[ebp-00000138]
push edx //빈공간 생성
mov eax,[factory]
mov ecx,[eax]
mov edx,[factory]//[ebp-08]
push edx
mov eax,[ecx+38]
call eax

cvtsi2ss xmm0,[ebp-e8]
movss [FloatX],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,[ebp-e8+4]
movss [FloatY],xmm0 { (0.00) } //X저장


mov ebx,[ebp+4]
mov [esp],ebx //terminateThread
ret





[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>913</ID>
          <Description>"메인 팩토리 3 인자 생성기 (쓰레드생성)"</Description>
          <LastState Activated="1"/>
          <Color>008080</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
WICImagingFactory2:
db E8 06 7D 31 24 5F 3D 43 BD F7 79 CE 68 D8 AB C2 00 00 00 00 CA 49 E7 F0 EF ED 89 45 A7 3A EE 0E 62 6A 2A 2B 00 00 00 00 FD 30 7A 25 B6 06 2B 46 AE A4 63 F7 0B 86 E5 33 00 00 00 00 7B A1 9E 38 78 50 DE 4C B6 EF 25 C1 51 75 C7 51 00 00 00 00//

GUIID:
db A9 C8 5E EC 95 C3 14 43 9C 77 54 D7 A9 35 FF 70 00 00 80 3F 6E 00 65 00 77 00 5F 00 30 00 30 00 31 00 2E 00 70 00 6E 00 67 00 00 00 00 00 00 00 64 00 78 00 32 00 5F 00 74 00 73 00 30 00 30 00 00 00 00 00 00

GUIFormat:
db 24 C3 DD 6F 03 4E FE 4B B1 85 3D 77 76 8D C9 10 00 00 00 00 24 C3 DD 6F 03 4E FE 4B B1 85 3D 77 76 8D C9 11 00 00 00 00 95 6B 8C D9 FE 3E D6 47 BB 25 EB 17 48 AB 0C F1 00 00 00 00

labeL(ebp14)
labeL(ebp20)
labeL(ebp2c)


factoryCreate3X:
push factoryX
push GUIID//WindowsProjeddct5._GUID_ec5ec8a9_c395_4314_9c77_54d7a935ff70 { (-329332567) }
push 01 { 1 }
push 00 { 0 }
push WICImagingFactory2//WindowsProjeddct5.CLSID_WICImagingFactory2 { (830277352) }
call combase.CoCreateInstance





//방 할당
call malloc24
push 1
call sleep
mov edi,[ebp+20]
mov ecx,[ebp+1c]
mov [ebp+1c],ecx//copyMemory+140
mov eax,[factoryX]
mov [edi+c],ecx
mov [edi-8],eax
mov eax,[factory+4]
mov [edi+8],eax
mov [edi-38],00000000 { 0 }
mov esi,esp
ebp14:
lea eax,[edi-14]
push eax //빈공란 데이터 이너미
push 00 { 0 }
push 80000000 { -2147483648 }
push 00 { 0 }
mov ecx,[edi+0C]
push ecx
mov edx,[edi-08]
mov eax,[edx]
mov ecx,[edi-08]
push ecx
mov edx,[eax+0C]
call edx
cmp [edi-14],0
je ebp14
cmp [edi-14],-1
je ebp14

mov edi,[edi-14]
test edi,edi
je ebp14
mov ecx,[edi+18]
mov edx,[edi+1c]
mov esi,[4Count]
mov edi,esi
add edi,esi
mov [ValueList+edi-8],ecx
mov [ValueList+edi-4],edx

ebp20:
//// WindowsPro////ddct5.LoadMyImage+1A0
mov edi,[ebp+20]
mov esi,esp
lea eax,[edi-20]
push eax
push 00 { 0 }
mov ecx,[edi-14]
mov edx,[ecx]
mov eax,[edi-14]
push eax
mov ecx,[edx+34]
call ecx
cmp [edi-20],0
je ebp20
cmp [edi-20],-1
je ebp20


ebp2c:
mov edi,[ebp+20]
//// WindowsPro////ddct5.LoadMyImage+189
mov esi,esp
lea eax,[edi-2C]
push eax
mov ecx,[edi-08]
mov edx,[ecx]
mov eax,[edi-08]
push eax
mov ecx,[edx+28]
call ecx
cmp [edi-2c],0
je ebp2c
cmp [edi-2c],-1
je ebp2c



mov edi,[ebp+20]
//// WindowsPro////ddct5.LoadMyImage+172
mov esi,esp
push 00 { 0 }
sub esp,08 { 8 }
xorps xmm0,xmm0
movsd [esp],xmm0
push 00 { 0 }
push 00 { 0 }
push GUIFormat////ddct5.GUID_WICPixelFormat32bppPBGRA { 0041A2EC }
mov eax,[edi-20]
push eax
mov ecx,[edi-2C]
mov edx,[ecx]
mov eax,[edi-2C]
push eax
mov ecx,[edx+20]
call ecx

cmp [edi-20],0
je ebp20
cmp [edi-20],-1
je ebp20


mov edi,[ebp+20]
//// WindowsPro////ddct5.LoadMyImage+15B
mov esi,esp
push [ebp+14] //factory+8 //load bit map ////ddct5.dx2p_bitmap { (0) }
push 00 { 0 }
mov eax,[edi-2C]
push eax
mov ecx,[edi+08]
mov edx,[ecx]
mov eax,[edi+08]
push eax
mov ecx,[edx+14]
call ecx

cmp [edi-2c],0
je ebp2c
cmp [edi-2c],-1
je ebp2c



mov edi,[ebp+20]
//// WindowsPro////ddct5.LoadMyImage+15B
mov [edi-38],00000001 { 1 }
mov eax,[edi-2C]
mov ecx,[eax]
mov esi,esp
mov edx,[edi-2C]
push edx
mov eax,[ecx+08]
call eax
cmp [edi-2c],0
je ebp2c
cmp [edi-2c],-1
je ebp2c


mov edi,[ebp+20]
mov eax,[edi-20]
mov ecx,[eax]
mov esi,esp
mov edx,[edi-20]
push edx
mov eax,[ecx+08]
call eax
cmp [edi-2c],0
je ebp20
cmp [edi-2c],-1
je ebp20

mov edi,[ebp+20]
mov eax,[edi-14]
mov ecx,[eax]
mov esi,esp
mov edx,[edi-14]
push edx
mov eax,[ecx+08]
call eax


mov edi,[ebp+20]
mov eax,[edi-08]
mov ecx,[eax]
mov esi,esp
mov edx,[edi-08]
push edx
mov eax,[ecx+08]
call eax

push [ebp+24]
call ucrtbased.free
add esp,4


ret





[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>914</ID>
          <Description>"메인 팩토리 3,4 인자 생성기 //터미네이터가 불안정함 (쓰레드생성)"</Description>
          <LastState Activated="1"/>
          <Color>008080</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
loadImageX:
push 1
call sleep
mov eax,[Pointer]
add [40Count],40
mov edi,[40Count]//변경//변경
add eax,edi
mov [ebp+1c],eax
mov [ebp+14],factory+4//고정
add [4Count],4
mov eax,[4Count]//변경//변경
add [ebp+14],eax //변경
call factoryCreate3X
ret




XYDiagram: //ebx 20카운팅 ecx 4카운팅
push 1
call sleep
add [ebp+c],4
add [ebp+8],20
mov edi,[ebp+c]
mov ecx,[Pointer+78] { (08033D70) }
sub ecx,4
mov ecx,[edi+ecx]
mov [ebp-e8],ecx
cvtsi2ss xmm0,[ebp-e8]
mov ecx,[UIIPointer]
mov ebx,[ebp+8]
add ecx,ebx
movss [ecx-4+edi],xmm0 { (0.00) } //Y저장

add [ebp+c],4
mov edi,[ebp+c]
mov ecx,[Pointer+78] { (08033D70) }
sub ecx,4
mov ecx,[edi+ecx]
mov [ebp-e8],ecx
cvtsi2ss xmm0,[ebp-e8]
mov ecx,[UIIPointer]
mov ebx,[ebp+8]
add ecx,ebx
movss [ecx-4+edi],xmm0 { (0.00) } //Y저장


ret

PathDiagram:
mov eax,[esp]
mov [ebp+4],eax//terminateSave

push eax
mov eax,00000420 { 71696 }
call diret
add esp,224

call loadImageX//1
call loadImageX //2
call loadImageX //3
call loadImageX //4
call loadImageX //5
call loadImageX //6
////////////Lgoin
call loadImageX//1
call loadImageX //2
call loadImageX //3
call loadImageX //4
call loadImageX //5
//Chane
call loadImageX//1
call loadImageX //2
call loadImageX //3
call loadImageX //4
//
call loadImageX//1
call loadImageX //2
call loadImageX //3
call loadImageX //4
call loadImageX //5
call loadImageX //6
mov [ebp+8],0
mov [ebp+c],0
call XYDiagram//1
call XYDiagram//2
call XYDiagram//3
call XYDiagram//4
call XYDiagram//5
call XYDiagram//6
////////////Lgoin
call XYDiagram//1
call XYDiagram//2
call XYDiagram//3
call XYDiagram//4
call XYDiagram//5
//Chaner
call XYDiagram//1
call XYDiagram//2
call XYDiagram//3
call XYDiagram//4
///캐릭터 생성 로직

call XYDiagram//1
call XYDiagram//2
call XYDiagram//3
call XYDiagram//4
call XYDiagram//5
call XYDiagram//6
add esp,200
mov ebp,esp
add ebp,c

mov eax,[ebp+4]
mov [esp],eax
ret



[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>915</ID>
          <Description>"브러쉬 인자 생성기"</Description>
          <LastState Activated="1"/>
          <Color>808080</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat


metaguiID:
db 5A EE 59 B8 38 D8 5B 4B A2 E8 1A DC 7D 93 DB 48 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

MetaInza:
push 1
call sleep
push Packtory { (02600D28) }
push metaguiID { (0.00) }
push 00 { 0 }
call DWrite.DWriteCreateFactory
ret


 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>916</ID>
          <Description>"브러쉬 메인 그리기 생성기"</Description>
          <LastState Activated="1"/>
          <Color>FF0080</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]


label(goto1)
label(goto2)
label(goto3)
operX:
push ebp
mov ebp,esp
jmp goto1//"WindowsProjeddct5.operator new"+12 { -&gt;WindowsProjeddct5.operator new+12 }
goto3:
push [ebp+08]
call ucrtbase.callnewh//WindowsProjeddct5._callnewh { -&gt;-&gt;ucrtbase.callnewh }
pop ecx
test eax,eax
je goto2//"WindowsProjeddct5.operator new"+21 { -&gt;WindowsProjeddct5.operator new+21 }
goto1:
push [ebp+08]
call ucrtbase.malloc //WindowsProjeddct5.malloc { -&gt;-&gt;ucrtbase.malloc }
pop ecx
test eax,eax
je goto3//"WindowsProjeddct5.operator new"+5 { -&gt;WindowsProjeddct5.operator new+5 }
pop ebp
ret
goto2:
ret
//cmp dword ptr [ebp+08],-01 { 255 }
//je WindowsProjeddct5.__scrt_throw_std_bad_array_new_length
//jmp WindowsProjeddct5.__scrt_throw_std_bad_alloc


label(7fffx)
label(leaesi)
label(7fffex2)
label(lea23x)
label(leaACDobule)
label(scrtX)
label(NullPointerX)
label(addebpC)
label(xorgateX)
label(returnd)
label(DeleateX)
label(returnDi)
MainMetaX:
push ebp
mov ebp,esp
push ecx
mov eax,[ebp+0C]
push ebx
push esi
push edi
mov edi,ecx
mov ecx,[edi+14]
mov [ebp-04],ecx
cmp eax,ecx
ja 7fffx//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+45 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+45 }
mov ebx,edi
cmp ecx,08 { 8 }
jb leaesi//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+1F { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+1F }
mov ebx,[edi]
lea esi,[eax+eax]
leaesi:
mov [edi+10],eax
push esi
push KEYSave//WindowsProjeddct5.exe+3278 { ("My Test Text!!") }
push ebx
call VCRUNTIME140.memcpy
add esp,0C { 12 }
xor eax,eax
mov [esi+ebx],ax
mov eax,edi
pop edi
pop esi
pop ebx
mov esp,ebp
pop ebp
ret 0008 { 8 }
7fffx:
mov esi,eax
or esi,07 { 7 }
cmp esi,7FFFFFFE { 2147483646 }
jna 7fffex2//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+69 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+69 }
mov esi,7FFFFFFE { 2147483646 }
mov eax,FFFFFFFE { -2 }
jmp lea23x//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+A3 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+A3 }
7fffex2:
mov edx,ecx
mov eax,7FFFFFFE { 2147483646 }
shr edx,1
sub eax,edx
cmp ecx,eax
jna leaACDobule//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+84 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+84 }
mov esi,7FFFFFFE { 2147483646 }
mov eax,FFFFFFFE { -2 }
jmp lea23x//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+A3 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+A3 }
leaACDobule:
lea eax,[edx+ecx]
cmp esi,eax
cmovb esi,eax
lea eax,[esi+01]
cmp eax,7FFFFFFF { 2147483647 }
ja scrtX//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+146 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+146 }
add eax,eax
cmp eax,00001000 { 4096 }
jb NullPointerX//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+CA { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+CA }
lea23x:
lea ecx,[eax+23]
cmp ecx,eax
jbe scrtX//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+146 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+146 }
push ecx
call operX//"WindowsProjeddct5.operator new"
add esp,04 { 4 }
test eax,eax
je ucrtbase.invalid_parameter_noinfo_noreturn //7000000상위 api "WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+140 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+140 }
lea ebx,[eax+23]
and ebx,-20 { 224 }
mov [ebx-04],eax
jmp addebpC//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+DD { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+DD }
NullPointerX:
test eax,eax
je xorgateX//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+DB { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+DB }
push eax
call operX//"WindowsProjeddct5.operator new"
add esp,04 { 4 }
mov ebx,eax
jmp addebpC//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+DD { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+DD }
xorgateX:
xor ebx,ebx
addebpC:
mov eax,[ebp+0C]
mov [edi+14],esi
mov [edi+10],eax
lea esi,[eax+eax]
push esi
push KEYSave//WindowsProjeddct5.exe+3278 { ("My Test Text!!") }
push ebx
call VCRUNTIME140.memcpy
xor eax,eax
add esp,0C { 12 }
mov [esi+ebx],ax
mov eax,[ebp-04]
cmp eax,08 { 8 }
jb returnd//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+133 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+133 }
lea ecx,[eax*2+00000002]
mov eax,[edi]
cmp ecx,00001000 { 4096 }
jb DeleateX//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+129 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+129 }
mov edx,[eax-04]
add ecx,23 { 35 }
sub eax,edx
add eax,-04 { 252 }
cmp eax,1F { 31 }
ja returnDi//"WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign"+140 { -&gt;WindowsProjeddct5.std::basic_string&lt;wchar_t,std::char_traits&lt;wchar_t&gt;,std::allocator&lt;wchar_t&gt; &gt;::assign+140 }
mov eax,edx
DeleateX:
push ecx
push eax
call ucrtbase.free//"WindowsProjeddct5.operator delete"
add esp,08 { 8 }
returnd:
mov [edi],ebx
mov eax,edi
pop edi
pop esi
pop ebx
mov esp,ebp
pop ebp
ret 0008 { 8 }
returnDi:
call ucrtbase.invalid_parameter_noinfo_noreturn
scrtX:
//call WindowsProjeddct5.__scrt_throw_std_bad_array_new_length
//call WindowsProjeddct5.std::_Xlen_string
int 3
int 3
int 3
int 3




BrushMainX:

push eax
mov eax,00000420 { 71696 }
call diret

mov eax,[factory+4] { (02790B30) }
lea edx,[ebp-000000A0]
movaps xmm0,[BrashFloat1D0+10] { (1.00) }
movups [ebp-000000A0],xmm0
push edx
mov ecx,[eax]
push eax
call dword ptr [ecx+000000BC]
mov eax,[factory+4] { (085B5340) }
lea edx,[ebp+0C]
movaps xmm0,[BrashFloat1D0] { (0) }
push edx
push 00 { 0 }
mov [ebp+0C],00000000 { 0 }
lea edx,[ebp-20]
movups [ebp-20],xmm0
mov ecx,[eax]
push edx
push eax
call dword ptr [ecx+20]

mov eax,[Packtory] { (085C46A0) }
lea edx,[ebp+14]
push edx
push Direct2DKEY-4 { (0) }
mov [ebp+14],00000000 { 0 }
mov ecx,[eax]
push ecx
mov [esp],43000000 { 128.00 }
push 05 { 5 }
push 00 { 0 }
push 00000090 { 144 }
push 00 { 0 }
push Direct2DKEY { ("Meiryo") }
push eax
call dword ptr [ecx+3C]



push 0E { 14 }
xor eax,eax
mov [ebp-44],00000000 { 0 }
push ecx
lea ecx,[ebp-44]
mov [ebp-34],00000000 { 0 }
mov [ebp-30],00000007 { 7 }
mov [ebp-44],ax
call MainMetaX

//



mov esi,[ebp+c]//[ebp+c]
mov [ebp-4c],(float)840
mov [ebp-4c+4],(float)540
movss xmm0,[ebp-4C]

push 00
push 00
push esi
lea esi,[ebp-6C]//임의의 방 할당
movss [ebp-64],xmm0
movss xmm0,[ebp-48]
push esi
mov edi,[ebp+14]
push edi
push [ebp-34]
mov [ebp-6C],00000000
mov [ebp-68],00000000
movss [ebp-60],xmm0
mov eax,[factory+4]
mov ecx,[eax]
mov edx,KEYSave
push edx
push eax
call dword ptr [ecx+6C]


add esp,424
mov ebp,esp
add ebp,c
ret




[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>917</ID>
              <Description>"LoginBrush"</Description>
              <LastState Activated="1"/>
              <Color>0000FF</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

LgoinBrush1:
mov eax,[factory+4] { (085B5340) }
lea edx,[ebp+0C]
movaps xmm0,[BrashFloat1D0] { (0) }
push edx
push 00 { 0 }
mov [ebp+0C],00000000 { 0 }
lea edx,[ebp-20]
movups [ebp-20],xmm0
mov ecx,[eax]
push edx
push eax
call dword ptr [ecx+20]
mov eax,[Packtory] { (085C46A0) }
lea edx,[ebp+14]
push edx
push Direct2DKEY-4 { (0) }
mov [ebp+14],00000000 { 0 }
mov ecx,[eax]
push ecx
mov [esp],(float)15 { 128.00 }
push 5 { 5 }
push 00 { 0 }
push 00000100 { 144 } //글씨 굵기
push 0 { 0 }
push Direct2DKEY { (0) }
push eax
call dword ptr [ecx+3C]
push 1a { 14 }//size
xor eax,eax
mov [ebp-44],00000000 { 0 }
push ecx
lea ecx,[ebp-44]
mov [ebp-34],00000000 { 0 }
mov [ebp-30],00000007 { 7 }
mov [ebp-44],ax
call MainMetaX
mov esi,[ebp+0C]
mov [ebp-4C],(float)840 { 840.00 }
mov [ebp-48],(float)540  { 540.00 }
movss xmm0,[ebp-4C]
push 0 { 0 }
push 0 { 1 }
push esi
lea esi,[ebp-6C]
movss [ebp-64],xmm0
movss xmm0,[ebp-48]
push esi
mov edi,[ebp+14]
push edi
push [ebp-34]
mov [ebp-6C],(float)333 { 0 }//x
mov [ebp-68],(float)328 { 0 }//y
movss [ebp-60],xmm0
mov eax,[factory+4] { (085B5340) }
mov ecx,[eax]
mov edx,KEYSave { ("Cy Test Text!!") }
push edx
push eax
call dword ptr [ecx+6C]
ret


[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>918</ID>
                  <Description>"LoginBrushsub"</Description>
                  <LastState Activated="1"/>
                  <Color>0000FF</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat



LgoinBrush12sub:
mov eax,[factory+4] { (085B5340) }
lea edx,[ebp+0C]
movaps xmm0,[BrashFloat1D0] { (0) }
push edx
push 00 { 0 }
mov [ebp+0C],00000000 { 0 }
lea edx,[ebp-20]
movups [ebp-20],xmm0
mov ecx,[eax]
push edx
push eax
call dword ptr [ecx+20]
mov eax,[Packtory] { (085C46A0) }
lea edx,[ebp+14]
push edx
push Direct2DKEY-4 { (0) }
mov [ebp+14],00000000 { 0 }
mov ecx,[eax]
push ecx
mov [esp],(float)15 { 128.00 }
push 5 { 5 }
push 00 { 0 }
push 00000100 { 144 } //글씨 굵기
push 0 { 0 }
push Direct2DKEY { (0) }
push eax
call dword ptr [ecx+3C]
push 14 { 14 }//size
xor eax,eax
mov [ebp-44],00000000 { 0 }
push ecx
lea ecx,[ebp-44]
mov [ebp-34],00000000 { 0 }
mov [ebp-30],00000007 { 7 }
mov [ebp-44],ax
call MainMetaX
mov esi,[ebp+0C]
mov [ebp-4C],(float)840 { 840.00 }
mov [ebp-48],(float)540  { 540.00 }
movss xmm0,[ebp-4C]
push 0 { 0 }
push 0 { 1 }
push esi
lea esi,[ebp-6C]
movss [ebp-64],xmm0
movss xmm0,[ebp-48]
push esi
mov edi,[ebp+14]
push edi
push [ebp-34]
mov [ebp-6C],(float)328 { 0 }//x
mov [ebp-68],(float)355{ 0 }//y
movss [ebp-60],xmm0
mov eax,[factory+4] { (085B5340) }
mov ecx,[eax]
mov edx,6CMeta { ("Cy Test Text!!") }
push edx
push eax
call dword ptr [ecx+6C]
ret

label(StartBrush12)

LgoinBrush12:
cmp [logoinSX],2
je LgoinBrush12sub
cmp [logoinSX],1
je StartBrush12
ret

StartBrush12:
mov eax,[factory+4] { (085B5340) }
lea edx,[ebp+0C]
movaps xmm0,[BrashFloat1D0] { (0) }
push edx
push 00 { 0 }
mov [ebp+0C],00000000 { 0 }
lea edx,[ebp-20]
movups [ebp-20],xmm0
mov ecx,[eax]
push edx
push eax
call dword ptr [ecx+20]
mov eax,[Packtory] { (085C46A0) }
lea edx,[ebp+14]
push edx
push Direct2DKEY-4 { (0) }
mov [ebp+14],00000000 { 0 }
mov ecx,[eax]
push ecx
mov [esp],(float)15 { 128.00 }
push 5 { 5 }
push 00 { 0 }
push 00000100 { 144 } //글씨 굵기
push 0 { 0 }
push Direct2DKEY { (0) }
push eax
call dword ptr [ecx+3C]
push 14 { 14 }//size
xor eax,eax
mov [ebp-44],00000000 { 0 }
push ecx
lea ecx,[ebp-44]
mov [ebp-34],00000000 { 0 }
mov [ebp-30],00000007 { 7 }
mov [ebp-44],ax
call MainMetaX
mov esi,[ebp+0C]
mov [ebp-4C],(float)840 { 840.00 }
mov [ebp-48],(float)540  { 540.00 }
movss xmm0,[ebp-4C]
push 0 { 0 }
push 0 { 1 }
push esi
lea esi,[ebp-6C]
movss [ebp-64],xmm0
movss xmm0,[ebp-48]
push esi
mov edi,[ebp+14]
push edi
push [ebp-34]
mov [ebp-6C],(float)329 { 0 }//x
mov [ebp-68],(float)328 { 0 }//y
movss [ebp-60],xmm0
mov eax,[factory+4] { (085B5340) }
mov ecx,[eax]
mov edx,6CMeta { ("Cy Test Text!!") }
push edx
push eax
call dword ptr [ecx+6C]
ret


[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>919</ID>
                  <Description>"MapleMeme-1"</Description>
                  <LastState Activated="1"/>
                  <Color>0000FF</Color>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

WorldBrushCh:
mov eax,[factory+4] { (085B5340) }
lea edx,[ebp+0C]
movaps xmm0,[BrashFloat1D0] { (0) }
push edx
push 00 { 0 }
mov [ebp+0C],00000000 { 0 }
lea edx,[ebp-20]
movups [ebp-20],xmm0
mov ecx,[eax]
push edx
push eax
call dword ptr [ecx+20]
mov eax,[Packtory] { (085C46A0) }
lea edx,[ebp+14]
push edx
push Direct2DKEY-4 { (0) }
mov [ebp+14],00000000 { 0 }
mov ecx,[eax]
push ecx
mov [esp],(float)13 { 128.00 }
push 5 { 5 }
push 00 { 0 }
push 00000100 { 144 } //글씨 굵기
push 0 { 0 }
push Direct2DKEY { (0) }
push eax
call dword ptr [ecx+3C]
push 1a { 14 }//size
xor eax,eax
mov [ebp-44],00000000 { 0 }
push ecx
lea ecx,[ebp-44]
mov [ebp-34],00000000 { 0 }
mov [ebp-30],00000007 { 7 }
mov [ebp-44],ax
call MainMetaX
mov esi,[ebp+0C]
mov [ebp-4C],(float)840 { 840.00 }
mov [ebp-48],(float)540  { 540.00 }
movss xmm0,[ebp-4C]
push 0 { 0 }
push 0 { 1 }
push esi
lea esi,[ebp-6C]
movss [ebp-64],xmm0
movss xmm0,[ebp-48]
push esi
mov edi,[ebp+14]
push edi
push [ebp-34]
mov [ebp-6C],(float)125 { 0 }//x
mov [ebp-68],(float)295 { 0 }//y
movss [ebp-60],xmm0
mov eax,[factory+4] { (085B5340) }
mov ecx,[eax]
mov edx,ChnerMenu { ("Cy Test Text!!") }
push edx
push eax
call dword ptr [ecx+6C]
ret


[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>920</ID>
          <Description>"시간 생성(타임 크레이트) (쓰레드생성)"</Description>
          <LastState Activated="1"/>
          <Color>808080</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

timeCreate:
push 00 { 0 }
push #1 { 50 } //timeSpeed
push 01 { 1 }
push [Handle]
call USER32.SetTimer
ret

 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>921</ID>
      <Description>"LoginBrush2"</Description>
      <LastState Activated="1"/>
      <Color>FF0080</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

LgoinBrush2:
mov eax,[factory+4] { (085B5340) }
lea edx,[ebp+0C]
movaps xmm0,[BrashFloat1D0] { (0) }
push edx
push 00 { 0 }
mov [ebp+0C],00000000 { 0 }
lea edx,[ebp-20]
movups [ebp-20],xmm0
mov ecx,[eax]
push edx
push eax
call dword ptr [ecx+20]
mov eax,[Packtory] { (085C46A0) }
lea edx,[ebp+14]
push edx
push Direct2DKEY-4 { (0) }
mov [ebp+14],00000000 { 0 }
mov ecx,[eax]
push ecx
mov [esp],(float)15 { 128.00 }
push 5 { 5 }
push 00 { 0 }
push 00000100 { 144 } //글씨 굵기
push 0 { 0 }
push Direct2DKEY { (0) }
push eax
call dword ptr [ecx+3C]
push 1a { 14 }//size
xor eax,eax
mov [ebp-44],00000000 { 0 }
push ecx
lea ecx,[ebp-44]
mov [ebp-34],00000000 { 0 }
mov [ebp-30],00000007 { 7 }
mov [ebp-44],ax
call MainMetaX
mov esi,[ebp+0C]
mov [ebp-4C],(float)840 { 840.00 }
mov [ebp-48],(float)540  { 540.00 }
movss xmm0,[ebp-4C]
push 0 { 0 }
push 0 { 1 }
push esi
lea esi,[ebp-6C]
movss [ebp-64],xmm0
movss xmm0,[ebp-48]
push esi
mov edi,[ebp+14]
push edi
push [ebp-34]
mov [ebp-6C],(float)333 { 0 }//x
mov [ebp-68],(float)355 { 0 }//y
movss [ebp-60],xmm0
mov eax,[factory+4] { (085B5340) }
mov ecx,[eax]
mov edx,KEYSave2 { ("Cy Test Text!!") }
push edx
push eax
call dword ptr [ecx+6C]
ret


[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>922</ID>
      <Description>"메인 팩토리 3,4 인자 생성기"</Description>
      <LastState Activated="1"/>
      <Color>C0C0C0</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

label(subdrdddX)

label(subapiR1)
label(subapiR2)
label(subapiR3)
label(subapiR1ret)
label(subapiR2ret)
label(subapiR3ret)
DirectXMainCon:
push ebp
mov ebp,esp
sub esp,000000C0 { 192 }
push ebx
push esi
push edi
mov edi,ebp
xor ecx,ecx
mov eax,CCCCCCCC { -858993460 }
repe stosd
mov eax,[factory+4] { (0343E1B8) }
mov ecx,[eax]
mov esi,esp
mov edx,[factory+4] { (0343E1B8) }
push edx
mov eax,[ecx+000000C0]
call eax


call imageDiagramX //loginBrush
call LgoinBrush12 //BlinkSum
call LgoinBrush1 //IDSUm
call LgoinBrush2 //PassWordSum

//mouse
//mov [ebp+24],#180
//mov [ebp+14],#20
//call imageDiagramXsub //5
//call CharTestDBVMX

push 25
call USER32.GetAsyncKeyState //&lt;&lt; key
shr ax,#15
cmp ax,1
je subapiR1
subapiR1ret: //&lt;&lt;
push 27
call USER32.GetAsyncKeyState //&gt;&gt; key
shr ax,#15
cmp ax,1
je subapiR2
subapiR2ret: //&gt;&gt;
//cmp [CountTimerjmp],0
jmp subapiR3
subapiR3ret: //jmp
push 00 { 0 }
push 00 { 0 }
mov eax,[factory+4] { (0343E1B8) }
mov ecx,[eax]
mov edx,[factory+4] { (0343E1B8) }
push edx
mov eax,[ecx+000000C4]
call eax
lea esp,[ebp+4]
lea ebp,[ebp+4]
inc [DebugCount]
mov edi,0
mov eax,0
mov ebx,0
mov ecx,0
jmp DirectXMainCon

subdrdddX:
call Charmovzero
push 00 { 0 }
push 00 { 0 }
mov eax,[factory+4] { (0343E1B8) }
mov ecx,[eax]
mov edx,[factory+4] { (0343E1B8) }
push edx
mov eax,[ecx+000000C4]
call eax
lea esp,[ebp+4]
lea ebp,[ebp+4]
inc [DebugCount]
mov edi,0
mov eax,0
mov ebx,0
mov ecx,0
jmp DirectXMainCon


subapiR1://&lt;&lt;
mov eax,Charmovzero
add eax,0 //5
call eax
jmp subapiR1ret
subapiR2://&gt;&gt;
mov eax,Charmovzero
add eax,5 //5
call eax
jmp subapiR2ret

subapiR3://&gt;&gt;
mov eax,Charmovzero
add eax,5 //5
add eax,5 //5
call eax
jmp subapiR3ret

[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>923</ID>
          <Description>"화면조정"</Description>
          <LastState Activated="1"/>
          <Color>808080</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]

scrinRestartsub:
add [ebp+24],28
mov ecx,[Pointer+40]
mov edi,[ebp+24]
lea ecx,[ecx+48+edi]
movss xmm0,[ecx] { (1520.00) }
addss xmm0,[ebp+c] { (244.00) }
movss [ecx],xmm0 { (1520.00) }
movss xmm0,[ebp+c] { (1520.00) }
movss [ecx-8],xmm0 { (1520.00) }
mov ecx,[Pointer+40]
mov edi,[ebp+24]
lea ecx,[ecx+4c+edi]
movss xmm0,[ecx] { (1520.00) }
addss xmm0,[ebp+10] { (296.00) }
movss [ecx],xmm0 { (1520.00) }
movss xmm0,[ebp+10] { (1520.00) }
movss [ecx-8],xmm0 { (1520.00) }
ret

scrinRestart:
//1화면
mov [ebp+c],(float)244
mov [ebp+10],(float)296
mov ecx,[Pointer+40]
lea ecx,[ecx+48]
movss xmm0,[ecx] { (1520.00) }
addss xmm0,[ebp+c] { (244.00) }
movss [ecx],xmm0 { (1520.00) }
movss xmm0,[ebp+c] { (1520.00) }
movss [ecx-8],xmm0 { (1520.00) }
mov ecx,[Pointer+40]
lea ecx,[ecx+4c]
movss xmm0,[ecx] { (1520.00) }
addss xmm0,[ebp+10] { (296.00) }
movss [ecx],xmm0 { (1520.00) }
movss xmm0,[ebp+10] { (1520.00) }
movss [ecx-8],xmm0 { (1520.00) }
//로그인 로고
mov [ebp+24],0
//2아이디 패스워드
mov [ebp+c],(float)283
mov [ebp+10],(float)413
call scrinRestartsub
//3 확인
mov [ebp+c],(float)369
mov [ebp+10],(float)424
call scrinRestartsub
//4 취소
mov [ebp+c],(float)441
mov [ebp+10],(float)423
call scrinRestartsub

//5마우스
mov [ebp+c],(float)441
mov [ebp+10],(float)423
call scrinRestartsub

//채널 스크린
mov [ebp+c],(float)0
mov [ebp+10],(float)0
call scrinRestartsub


//메뉴 스크린
mov [ebp+c],(float)78
mov [ebp+10],(float)79
call scrinRestartsub

mov [ebp+c],(float)305 //선택 버튼
mov [ebp+10],(float)510
call scrinRestartsub

mov [ebp+c],(float)99 //회색버튼
mov [ebp+10],(float)293
call scrinRestartsub

mov [ebp+c],(float)102 //채널아이콘
mov [ebp+10],(float)296
call scrinRestartsub
////
mov [ebp+c],(float)110 //캐릭터 선택창
mov [ebp+10],(float)116
call scrinRestartsub

mov [ebp+c],(float)414 //캐릭터 선택 버튼
mov [ebp+10],(float)407 //캐릭터 선택 버튼
call scrinRestartsub

mov [ebp+c],(float)414 //캐삭버튼
mov [ebp+10],(float)439 //캐삭버튼
call scrinRestartsub

mov [ebp+c],(float)414 //캐릭터 생성 버튼
mov [ebp+10],(float)470 //캐릭터 생성 버튼
call scrinRestartsub

mov [ebp+c],(float)193 //캐릭터 생성 버튼
mov [ebp+10],(float)331 //캐릭터 생성 버튼
call scrinRestartsub

//캐릭터 대머리
mov [ebp+c],(float)182 //캐릭터 생성 버튼
mov [ebp+10],(float)295 //캐릭터 생성 버튼
call scrinRestartsub

ret






[DISABLE]

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>924</ID>
          <Description>"마우스 디버그+깜빡임 관리기"</Description>
          <LastState Activated="1"/>
          <Color>808080</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

label(loginSetZero)
label(loginSetZero2)
label(woncodezero)
MouseMovs:
mov [ebp+20],0
mov [ebp+24],0
woncodezero:
push Mouseallocx//[Msize+f4]
call USER32.GetPhysicalCursorPos
push Mouseallocx
push [Handle]
call USER32.ScreenToClient
mov eax,[Mouseallocx]
mov ebx,[Mouseallocy]
mov ecx,[factory+8+8+c]
mov edi,[ecx-84]
mov esi,[ecx-80]
add edi,eax
add esi,ebx

mov [ebp+10],eax
mov [ebp+14],ebx
mov [ebp+18],edi
mov [ebp+1c],esi
xor eax,eax
xor ebx,ebx
xor edi,edi
xor esi,esi

mov ecx,[Pointer+40]
lea ecx,[ecx+cc]
cvtsi2ss xmm0,[ebp+10]
movss [ecx],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,[ebp+14]
movss [ecx+4],xmm0 { (0.00) } //X저장

cvtsi2ss xmm0,[ebp+18]
movss [ecx+8],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,[ebp+1c]
movss [ecx+c],xmm0 { (0.00) } //X저장

inc [ebp+20]
cmp [ebp+20],#80
jae loginSetZero2
cmp [ebp+20],#40
jae loginSetZero
push 1
call sleep
jmp woncodezero

loginSetZero:
mov [6CMeta],0
push 1
call sleep
jmp woncodezero


loginSetZero2:
mov [ebp+20],0
mov [6CMeta],6c
jmp woncodezero





[DISABLE]



</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>925</ID>
          <Description>"로그인 스위치 관리기"</Description>
          <LastState Activated="1"/>
          <Color>808080</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]

label(EamulX1)

label(EamulY1)
label(EamulY2)
label(EamulYB2)
label(login1)
label(login2)

LgoinSwitchContolo:
push 1
call sleep
mov eax,[basep]
test eax,eax
je LgoinSwitchContolo
lea eax,[eax+30]
test eax,eax
je LgoinSwitchContolo
cmp [eax],#161
jne LgoinSwitchContolo
cmp [Mouseallocx],#326
jae EamulX1
jmp LgoinSwitchContolo

EamulX1:
cmp [Mouseallocx],#506
jbe EamulY1
jmp LgoinSwitchContolo


EamulY1:
cmp [Mouseallocy],#357
jae EamulYB2
cmp [Mouseallocy],#330
jae EamulY2
jmp LgoinSwitchContolo

EamulY2:
cmp [Mouseallocy],#349
jbe login1
jmp LgoinSwitchContolo

EamulYB2:
cmp [Mouseallocy],#374
jbe login2
jmp LgoinSwitchContolo

login1:
mov [logoinSX],1
jmp LgoinSwitchContolo

login2:
mov [logoinSX],2
jmp LgoinSwitchContolo

[DISABLE]



</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>926</ID>
              <Description>"캐릭터 이동로직"</Description>
              <LastState Activated="1"/>
              <Color>00FF00</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

label(addPadd1)
label(addPadd2)
label(addPadd3)

label(returndddX)



Charmovzero:

jmp addPadd2
jmp addPadd3
jmp returndddX


returndddX:

mov eax,[UIIPointer]
lea eax,[eax+270] //+28
mov ebx,[charX]//#185 //x
mov ecx,[charY]//#185 //x
mov edi,ebx
add edi,#21
mov esi,ecx
add esi,#31
cvtsi2ss xmm0,ebx
movss [eax],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,ecx
movss [eax+4],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,edi
movss [eax+8],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,esi
movss [eax+c],xmm0 { (0.00) } //Y저장
//몸통
mov eax,[UIIPointer]
lea eax,[eax+270+28]
mov ebx,[charX]//#185 //x
mov ecx,[charY]//#185 //x
sub ebx,#6
sub ecx,#34
mov edi,ebx
add edi,#39
mov esi,ecx
add esi,#35
cvtsi2ss xmm0,ebx
movss [eax],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,ecx
movss [eax+4],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,edi
movss [eax+8],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,esi
movss [eax+c],xmm0 { (0.00) } //Y저장

//핸드
mov eax,[UIIPointer]
lea eax,[eax+270+28+28]
mov ebx,[charX]//#185 //x
add ebx,#15
mov ecx,[charY]//#185 //x
add ecx,#2
mov edi,ebx
//사이즈
add edi,#11
mov esi,ecx
add esi,#19
cvtsi2ss xmm0,ebx
movss [eax],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,ecx
movss [eax+4],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,edi
movss [eax+8],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,esi
movss [eax+c],xmm0 { (0.00) } //Y저장


//핸드
mov eax,[UIIPointer]
lea eax,[eax+270+28+28]
mov ebx,[charX]//#185 //x
add ebx,#15
mov ecx,[charY]//#185 //x
add ecx,#2
mov edi,ebx
//사이즈
add edi,#11
mov esi,ecx
add esi,#19
cvtsi2ss xmm0,ebx
movss [eax],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,ecx
movss [eax+4],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,edi
movss [eax+8],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,esi
movss [eax+c],xmm0 { (0.00) } //Y저장

//눈깔
mov eax,[UIIPointer]
lea eax,[eax+270+28+28+28]
mov ebx,[charX]//#185 //x
sub ebx,#2
mov ecx,[charY]//#185 //x
sub ecx,#19
mov edi,ebx
//사이즈
add edi,#26
mov esi,ecx
add esi,#17
cvtsi2ss xmm0,ebx
movss [eax],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,ecx
movss [eax+4],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,edi
movss [eax+8],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,esi
movss [eax+c],xmm0 { (0.00) } //Y저장



//헤어
mov eax,[UIIPointer]
lea eax,[eax+270+28+28+28]
mov ebx,[charX]//#185 //x
sub ebx,#2
mov ecx,[charY]//#185 //x
sub ecx,#19
mov edi,ebx
//사이즈
add edi,#26
mov esi,ecx
add esi,#17
cvtsi2ss xmm0,ebx
movss [eax],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,ecx
movss [eax+4],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,edi
movss [eax+8],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,esi
movss [eax+c],xmm0 { (0.00) } //Y저장

mov eax,[UIIPointer]
lea eax,[eax+270+28+28+28+28]
mov ebx,[charX]//#185 //x
sub ebx,#11
mov ecx,[charY]//#185 //x
sub ecx,#36
mov edi,ebx
//사이즈
add edi,#44
mov esi,ecx
add esi,#38
cvtsi2ss xmm0,ebx
movss [eax],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,ecx
movss [eax+4],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,edi
movss [eax+8],xmm0 { (0.00) } //Y저장
cvtsi2ss xmm0,esi
movss [eax+c],xmm0 { (0.00) } //Y저장
ret





addPadd1:
push 25
call USER32.GetAsyncKeyState //key
shr ax,#15
cmp ax,1
je addPadd2
push 27
call USER32.GetAsyncKeyState //key
shr ax,#15
cmp ax,1
je addPadd3
push 1
call sleep
jmp Charmovzero

addPadd2:
sub [charX],3
jmp returndddX

addPadd3:
add [charX],3
jmp returndddX



[DISABLE]
Charmovzero:
ret
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>927</ID>
          <Description>"캐릭터jmp"</Description>
          <LastState Activated="1"/>
          <Color>C0C0C0</Color>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]

label(startjmp1)
label(startjmp2)

timerapi2:
mov [CountTimerjmp],0
push #164
call USER32.GetAsyncKeyState //key
shr ax,#15
cmp ax,1
je startjmp1
push 1
call sleep
jmp timerapi2

startjmp1:
push 00 { 0 }
push 01 { 1 }
push 00 { 0 }
mov [esp+14],-2{ -100000000 }
mov [esp+18],-1 { -1 }
call KERNEL32.CreateWaitableTimerW
mov esi,eax
lea eax,[esp+08]
push 00 { 0 }
push 00 { 0 }
push 00 { 0 }
push 00 { 0 }
push eax
push esi
call KERNEL32.SetWaitableTimer
push -01 { 255 }
push esi
call KERNELBASE.WaitForSingleObject
add [CountTimerjmp],4
dec [charY]
dec [charY]
dec [charY]
dec [charY]

cmp [CountTimerjmp],#76
jae startjmp2
jmp startjmp1

label(subsB)
label(subsX)

subsX:
push esi
call KERNEL32.CloseHandle
jmp timerapi2


startjmp2:
push 00 { 0 }
push 01 { 1 }
push 00 { 0 }
mov [esp+14],#-2 { -100000000 }
mov [esp+18],FFFFFFFF { -1 }
call KERNEL32.CreateWaitableTimerW
mov esi,eax
subsB:
lea eax,[esp+08]
push 00 { 0 }
push 00 { 0 }
push 00 { 0 }
push 00 { 0 }
push eax
push esi
call KERNEL32.SetWaitableTimer
push -01 { 255 }
push esi
call KERNELBASE.WaitForSingleObject
cmp [CountTimerjmp],#0
jbe subsX
cmp [CountTimerjmp],-1
je subsX
cmp [CountTimerjmp],-2
je subsX
cmp [CountTimerjmp],-3
je subsX
cmp [CountTimerjmp],-4
je subsX
sub [CountTimerjmp],4
inc [charY]
inc [charY]
inc [charY]
inc [charY]
jmp subsB
[DISABLE]

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>928</ID>
              <Description>"쓰레드 스타트"</Description>
              <LastState Activated="1"/>
              <Color>0000FF</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
main: //startapiX
push eax
mov eax,00000320 { 71696 }
call diret
add esp,124

call IATGate //IAT뱉어내게 하기
call MChapi//문자열 유니코드 변환

add esp,200
mov ebp,esp
add ebp,c
mov ecx,LoginMain //GUI쓰레드 콜
call Th //쓰레드 콜
push #200
call sleep
ret
mov ecx,factoryCreate
call Th //쓰레드 콜
push #200
call sleep
mov ecx,PathDiagram
call Th //쓰레드 콜
push #1000
call sleep
mov ecx,MetaInza
call Th //쓰레드 콜
push #100
call sleep
mov ecx,timeCreate
call Th //쓰레드 콜
push #100
call sleep
mov ecx,DirectXMainCon
call Th //쓰레드 콜
push #100
call sleep
mov ecx,scrinRestart
call Th //쓰레드 콜
mov ecx,MouseMovs
call Th //쓰레드 콜

mov ecx,timerapi2
call Th //쓰레드 콜

mov ecx,LgoinSwitchContolo
call Th //쓰레드 콜

ret



createThread(main)
[DISABLE]

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>929</ID>
              <Description>"testcall"</Description>
              <LastState Activated="1"/>
              <Color>0000FF</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
////////////////////ErrorSymbol
define(allocError,1541)
Registersymbol(allocError)
define(D3DInitializeError,1542)
Registersymbol(D3DInitializeError)
//////////////////ErrorSymbol



define(m_Direct3Dcrea,00701000)
Registersymbol(m_Direct3Dcrea)
define(m_Direct3DObject,01551000)
Registersymbol(m_Direct3DObject)
m_Direct3Dcrea:
label(debugX)
label(startalloc2)

push 10 { 16 }
call OperX//"Dx11Demo_11.operator new"
add esp,14 { 20 }
mov ecx,eax
mov [eax],00000000 { 0 }
mov [eax+04],00000000 { 0 }
mov [eax+08],00000000 { 0 }
mov [eax+0C],00000000 { 0 }
push 10 { 0000002C }
call operX//"Dx11Demo_11.operator new"
//zeromemory
mov [eax],0
mov [eax+4],0
mov [eax+8],0
mov [eax+c],0

mov ecx,eax
mov edi,ecx
add esp,4 { 8 }

push #16//10 { 16 }
push #384 { 384 }
call ucrtbase.aligned_malloc
add esp,8
mov esi,eax
test esi,esi
je debugX
mov [m_Direct3DObject],esi
//ZeroMemory Dx11Demo_11.GraphicsClass::Initialize+A9 - mov ebx,[ebp+10]
push 00000080 //Set할 사이즈
lea ecx,[esi+8]
mov byte ptr [esi],0
push 00
push ecx
mov [esi+4],0
call VCRUNTIME140.memset
add esp,0C
mov [esi+00000088],00000000 { 0 }
mov [esi+0000008C],00000000 { 0 }
mov [esi+00000090],00000000 { 0 }
mov [esi+00000094],00000000 { 0 }
mov [esi+00000098],00000000 { 0 }
mov [esi+0000009C],00000000 { 0 }
mov [esi+000000A0],00000000 { 0 }
mov [esi+000000A4],00000000 { 0 }
mov [esi+00000170],00000000 { 0 }
mov [edi],esi//Set
test esi,esi
je NullPointer2

mov ebx,[Handle]//HWND
sub esp,0C { 12 }
mov [esp+08],(float)0.10//3DCCCCCD { 0.10 }
mov [esp+04],(float)1000.00//0.10447A0000 { 1000.00 }
push ebx
push ecx
mov ebx,[Handle]//HWND
mov [ebp+10],ebx
mov [ebp+c],258//#600
mov [ebp+8],320//#800
push [ebp+0C]
mov ecx,esi
push [ebp+08]
call D3DInitialize
test al,al
jne startalloc2
mov [ErrorDebug],allocError
ret

debugX:
mov [ErrorDebug],D3DInitializeError
ret

label(NullPointer1)
label(NullPointer2)
label(EndPointer1)
label(EndPointer2)
label(CreateBitmapSaveX2C)
label(Error07X)

startalloc2:
mov esi,aligned_malloc//[PointerAPI1]//aligned_malloc//apiX
push 10 { 00000010 }
push 60 { 96 }
call esi
mov ecx,eax
add esp,08 { 8 }
mov [ebp+10],ecx//[hwnd],ecx
test ecx,ecx
je EndPointer1//Dx11Demo_11.GraphicsClass::Initialize+270
xorps xmm1,xmm1
mov [ebp-08],00000000 { 0 }
mov eax,[ebp-08]
xorps xmm0,xmm0
unpcklps xmm0,xmm1
movq [ecx],xmm0
mov [ecx+08],eax
unpcklps xmm1,xmm1
movq [ecx+0C],xmm1
mov [ebp-08],00000000 { 0 }
mov eax,[ebp-08]
mov [ecx+14],eax
mov [edi+04],ecx
	// m_TextureShader 객체 생성
	//m_TextureShader = new TextureShaderClass;
push 10 { 00000010 }
push 14 { 00000014 }
/*
	// 카메라 포지션 설정
	m_Camera-&gt;SetPosition(0.0f, 0.0f, -6.0f);
*/
mov [ecx],00000000 { 0 }
mov [ecx+04],00000000 { 0 }
mov [ecx+08],C0C00000 { -6.00 }
call esi

mov ecx,eax
add esp,08 { 8 }
mov [ebp+10],ecx
test ecx,ecx
je EndPointer2//Dx11Demo_11.GraphicsClass::Initialize+25E
mov [ecx],00000000 { 0 }
sub esp,08 { 8 }
/*
	// m_TextureShader 객체 초기화
	if (!m_TextureShader-&gt;Initialize(m_Direct3D-&gt;GetDevice(), hwnd))
*/

	// m_TextureShader 객체 생성
	//m_TextureShader = new TextureShaderClass;

mov [ecx+04],00000000 { 0 }
mov [ecx+08],00000000 { 0 }
mov [ecx+0C],00000000 { 0 }
mov [ecx+10],00000000 { 0 }
// m_TextureShader 객체 초기화
//	if (!m_TextureShader-&gt;Initialize(m_Direct3D-&gt;GetDevice(), hwnd))
lea eax,[edi]
mov [m_TextureShaderDBVMX],eax
mov eax,[edi]
push ebx
	// m_TextureShader 객체 생성
//	m_TextureShader = new TextureShaderClass;

// m_TextureShader 객체 초기화
//	if (!m_TextureShader-&gt;Initialize(m_Direct3D-&gt;GetDevice(), hwnd))
mov [edi+08],ecx //save
push [eax+0000008C]
call TextureShaderClassDBVM//Dx11Demo_11.TextureShaderClass::InitializeShader
test al,al
jne CreateBitmapSaveX2C//Dx11Demo_11.GraphicsClass::Initialize+1C0
mov [ErrorDebug],7
pop edi
pop esi
xor al,al
pop ebx
mov esp,ebp
pop ebp
ret 000C { 12 }
CreateBitmapSaveX2C:
	// 비트맵 객체 생성
//	m_Bitmap = new BitmapClass;
push 2C { 0000002C }
call operX//"Dx11Demo_11.operator new"
mov ecx,eax
sub esp,08 { 8 }
mov [ebp+10],ecx
push [ebp+0C]//[screenHeight]
	// 비트맵 객체 생성
//	m_Bitmap = new BitmapClass;
mov [ecx],00000000 { 0 }
push [ebp+08]//004037A8  push        dword ptr [screenWidth]

mov [ecx+04],00000000 { 0 }
mov [ecx+08],00000000 { 0 }
mov [ecx+0C],00000000 { 0 }
mov [ecx+10],00000000 { 0 }
mov [ecx+14],00000000 { 0 }
mov [ecx+18],00000000 { 0 }
mov [ecx+1C],00000000 { 0 }
mov [ecx+20],00000000 { 0 }
mov [ecx+24],00000000 { 0 }
mov [ecx+28],00000000 { 0 }
mov eax,[edi]
mov [edi+0C],ecx
push [eax+0000008C]
call DXBitmapClassInitialize //Dx11Demo_11.BitmapClass::Initialize
test al,al
jne Error07X//Dx11Demo_11.GraphicsClass::Initialize+253
mov [ErrorDebug],6
pop edi
pop esi
xor al,al
pop ebx
mov esp,ebp
pop ebp
ret 000C { 12 }
Error07X:
push #80000000
call sleep
pop edi
pop esi
mov al,01 { 1 }
pop ebx
mov esp,ebp
pop ebp
ret 000C { 12 }
EndPointer2:
mov [edi+08],00000000 { 0 }
xor al,al
pop edi
pop esi
pop ebx
mov esp,ebp
pop ebp
ret 000C { 12 }
EndPointer1:
mov [edi+04],00000000 { 0 }
xor al,al
pop edi
pop esi
pop ebx
mov esp,ebp
pop ebp
ret 000C { 12 }
NullPointer1:
mov [edi],00000000 { 0 }
NullPointer2:
pop edi
pop esi
xor al,al
pop ebx
mov esp,ebp
pop ebp
ret 000C { 12 }



label(goto11)
label(goto12)
label(goto13)
operX:
push ebp
mov ebp,esp
jmp goto11//"WindowsProjeddct5.operator new"+12 { -&gt;WindowsProjeddct5.operator new+12 }
goto13:
push [ebp+08]
call ucrtbase.callnewh//WindowsProjeddct5._callnewh { -&gt;-&gt;ucrtbase.callnewh }
pop ecx
test eax,eax
je goto12//"WindowsProjeddct5.operator new"+21 { -&gt;WindowsProjeddct5.operator new+21 }
goto11:
push [ebp+08]
call ucrtbase.malloc //WindowsProjeddct5.malloc { -&gt;-&gt;ucrtbase.malloc }
pop ecx
test eax,eax
je goto13//"WindowsProjeddct5.operator new"+5 { -&gt;WindowsProjeddct5.operator new+5 }
pop ebp
ret
goto12:
ret




createThread(m_Direct3Dcrea)
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>1040</ID>
      <Description>"testcall::CameraX"</Description>
      <LastState Activated="1"/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

CameraXDBVM:
push ebx
mov ebx,esp
sub esp,08 { 8 }
and esp,-10 { 240 }
add esp,04 { 4 }
push ebp
mov ebp,[ebx+04]
mov [esp+04],ebp
mov ebp,esp
sub esp,30 { 48 }
movss xmm2,[CameraX] { (1.00) }
xorps xmm3,xmm3
mov eax,[ecx+08]
movaps xmm0,xmm2
movaps xmm1,xmm3
mov [ebp-04],eax
unpcklps xmm1,xmm0
movaps xmm0,xmm3
movlhps xmm1,xmm0
movq xmm0,[ecx]
movaps [ebp-20],xmm1
movss xmm1,[ebp-04]
movq [ebp-0C],xmm0
movaps xmm0,xmm2
movsd xmm4,[ebp-0C]
movss xmm2,[ecx+10]
movlhps xmm4,xmm1
movaps xmm1,xmm3
movss xmm3,[ecx+14]
movlhps xmm1,xmm0
movss xmm0,[CameraX-4] { (0.02) }
movaps [ebp-10],xmm1
movss xmm1,[ecx+0C]
mulss xmm1,xmm0
mulss xmm3,xmm0
mulss xmm2,xmm0
unpcklps xmm1,xmm3
movaps [ebp-30],xmm4
unpcklps xmm1,xmm2
movaps xmm0,xmm1
//call Dx11Demo_11.DirectX::XMQuaternionRotationRollPitchYawFromVector
movaps xmm3,xmm0
movaps xmm7,[IDENTY3+10] { (1.00) }
movaps xmm4,xmm3
shufps xmm0,xmm3,-30 { 208 }
addps xmm4,xmm3
movaps xmm2,xmm4
mulps xmm2,xmm3
shufps xmm3,xmm3,-01 { 255 }
movaps xmm1,xmm2
shufps xmm1,xmm2,-3F { 193 }
andps xmm1,[RxS3] { (-1) }
subps xmm7,xmm1
shufps xmm2,xmm2,-26 { 218 }
andps xmm2,[RxS3] { (-1) }
movaps xmm1,xmm4
shufps xmm1,xmm4,-1A { 230 }
shufps xmm4,xmm4,-37 { 201 }
mulps xmm4,xmm3
mulps xmm1,xmm0
subps xmm7,xmm2
movaps xmm2,[ebp-10]
movaps xmm6,xmm4
addps xmm6,xmm1
movaps xmm5,xmm7
subps xmm1,xmm4
movaps xmm3,xmm7
movaps xmm4,xmm2
shufps xmm4,xmm2,-56 { 170 }
movaps xmm0,xmm6
shufps xmm6,xmm1,-60 { 160 }
shufps xmm0,xmm1,49 { 73 }
shufps xmm0,xmm0,78 { 120 }
shufps xmm6,xmm6,-78 { 136 }
shufps xmm6,xmm7,-1C { 228 }
movaps xmm7,[ebp-20]
shufps xmm5,xmm0,4C { 76 }
shufps xmm3,xmm0,-13 { 237 }
movaps xmm0,xmm2
mulps xmm4,xmm6
shufps xmm0,xmm2,55 { 85 }
shufps xmm3,xmm3,72 { 114 }
mulps xmm0,xmm3
addps xmm4,[IDENTY3] { (0.00) }
shufps xmm2,xmm2,00 { 0 }
shufps xmm5,xmm5,78 { 120 }
mulps xmm2,xmm5
addps xmm4,xmm0
addps xmm4,xmm2
movaps xmm2,xmm7
shufps xmm2,xmm7,-56 { 170 }
mulps xmm2,xmm6
movaps xmm0,xmm7
shufps xmm0,xmm7,55 { 85 }
mulps xmm0,xmm3
addps xmm2,[IDENTY3] { (0.00) }
shufps xmm7,xmm7,00 { 0 }
mulps xmm7,xmm5
addps xmm2,xmm0
movaps xmm0,[ebp-30]
addps xmm2,xmm7
movaps xmm3,xmm2
shufps xmm3,xmm2,-01 { 255 }
divps xmm2,xmm3
movaps xmm3,xmm4
shufps xmm3,xmm4,-01 { 255 }
divps xmm4,xmm3
addps xmm4,xmm0
subps xmm4,xmm0
movaps xmm1,xmm4
call XMMatrixLookToLHDBVM//Dx11Demo_11.DirectX::XMMatrixLookToLH
movups [ecx+20],xmm0
movups [ecx+30],xmm1
movups [ecx+40],xmm2
movups [ecx+50],xmm3
mov esp,ebp
pop ebp
mov esp,ebx
pop ebx
ret

 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>1041</ID>
          <Description>"testcall::CameraX::ThX"</Description>
          <LastState Activated="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

XMMatrixLookToLHDBVM:
push ebx
mov ebx,esp
sub esp,08 { 8 }
and esp,-10 { 240 }
add esp,04 { 4 }
push ebp
mov ebp,[ebx+04]
mov [esp+04],ebp
mov ebp,esp
sub esp,20 { 32 }
movaps xmm5,xmm1
movaps [ebp-20],xmm0
movaps xmm4,xmm5
movaps xmm1,[MiniTyX] { (2139095040) }
mulps xmm4,xmm5
movaps xmm6,xmm2
shufps xmm6,xmm6,-37 { 201 }
xorps xmm7,xmm7
movaps xmm3,xmm4
shufps xmm3,xmm4,-67 { 153 }
addss xmm4,xmm3
movaps xmm2,xmm3
shufps xmm2,xmm3,55 { 85 }
addss xmm4,xmm2
xorps xmm2,xmm2
shufps xmm4,xmm4,00 { 0 }
sqrtps xmm0,xmm4
cmpps xmm1,xmm4,04 { 4 }
divps xmm5,xmm0
cmpps xmm2,xmm0,04 { 4 }
movaps xmm0,xmm6
andps xmm2,xmm5
shufps xmm0,xmm6,-37 { 201 }
andps xmm2,xmm1
andnps xmm1,[MiniTyX+40] { (2143289344) }
orps xmm2,xmm1
movaps xmm3,xmm2
movaps [ebp-10],xmm2
shufps xmm3,xmm2,-2E { 210 }
movaps xmm1,xmm3
shufps xmm1,xmm3,-2E { 210 }
mulps xmm1,xmm0
mulps xmm3,xmm6
movaps xmm6,[ebp-10]
subps xmm3,xmm1
andps xmm3,[MiniTyX+30] { (-1) }
movaps xmm2,xmm3
mulps xmm2,xmm3
movaps xmm1,xmm2
shufps xmm1,xmm2,-67 { 153 }
addss xmm2,xmm1
movaps xmm0,xmm1
shufps xmm0,xmm1,55 { 85 }
addss xmm2,xmm0
shufps xmm2,xmm2,00 { 0 }
sqrtps xmm0,xmm2
cmpps xmm2,dqword ptr [MiniTyX+30],04 { 4,(+Inf) }
divps xmm3,xmm0
cmpps xmm7,xmm0,04 { 4 }
andps xmm7,xmm3
andps xmm7,xmm2
andnps xmm2,[MiniTyX+40] { (2143289344) }
orps xmm7,xmm2
movaps xmm2,xmm6
shufps xmm2,xmm6,-37 { 201 }
movaps xmm5,xmm7
shufps xmm5,xmm7,-2E { 210 }
movaps xmm0,xmm2
movaps xmm1,xmm5
shufps xmm0,xmm2,-37 { 201 }
shufps xmm1,xmm5,-2E { 210 }
mulps xmm1,xmm0
mulps xmm5,xmm2
xorps xmm2,xmm2
subps xmm2,[ebp-20]
subps xmm5,xmm1
movaps xmm4,xmm2
movaps xmm3,xmm2
mulps xmm4,xmm7
andps xmm5,[MiniTyX+50] { (-1) }
mulps xmm3,xmm5
movaps xmm1,xmm4
shufps xmm1,xmm4,-67 { 153 }
movaps xmm0,xmm1
addss xmm4,xmm1
shufps xmm0,xmm1,55 { 85 }
movaps xmm1,xmm3
shufps xmm1,xmm3,-67 { 153 }
addss xmm4,xmm0
movaps xmm0,xmm1
shufps xmm0,xmm1,55 { 85 }
mulps xmm2,xmm6
addss xmm3,xmm1
shufps xmm4,xmm4,00 { 0 }
movaps xmm1,xmm2
addss xmm3,xmm0
shufps xmm1,xmm2,-67 { 153 }
addss xmm2,xmm1
movaps xmm0,xmm1
shufps xmm0,xmm1,55 { 85 }
shufps xmm3,xmm3,00 { 0 }
addss xmm2,xmm0
movaps [ebp-20],xmm2
movaps xmm2,[MiniTyX+50] { (-1) }
movaps xmm6,xmm2
movaps xmm0,xmm2
andps xmm0,xmm7
andnps xmm6,xmm4
orps xmm6,xmm0
movaps xmm1,xmm2
movaps xmm0,xmm2
andnps xmm1,xmm3
andps xmm0,xmm5
movaps xmm4,xmm6
orps xmm1,xmm0
movaps xmm5,xmm2
movaps xmm0,[ebp-20]
andps xmm2,[ebp-10]
shufps xmm0,xmm0,00 { 0 }
andnps xmm5,xmm0
shufps xmm4,xmm1,44 { 68 }
orps xmm5,xmm2
shufps xmm6,xmm1,-12 { 238 }
movaps xmm2,xmm5
movaps xmm0,xmm4
shufps xmm2,[IDENTY3],44 { 68,(0.00) }
shufps xmm5,[IDENTY3],-12 { 238,(0.00) } //Error가 일어날 수 있음
shufps xmm4,xmm2,-23 { 221 }
shufps xmm0,xmm2,-78 { 136 }
movaps xmm1,xmm4
movaps xmm2,xmm6
shufps xmm6,xmm5,-23 { 221 }
shufps xmm2,xmm5,-78 { 136 }
movaps xmm3,xmm6
mov esp,ebp
pop ebp
mov esp,ebx
pop ebx
ret

 
 
[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>1037</ID>
              <Description>"Th"</Description>
              <LastState Activated="1"/>
              <Color>0000FF</Color>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
//code from here to '[DISABLE]' will be used to enable the cheat

ThX:
push ebp
mov ebp,esp
and esp,-10 { 240 }
sub esp,00000198 { 408 }
push esi
push edi
mov edi,ecx
mov edi,[m_TextureShaderDBVMX]
mov [esp+1C],edi
mov ecx,[edi+04]
lea ecx,[esp+20]
push ecx
movups [esp+24],xmm0
mov [esp+20],edi
mov esi,[edi]
mov eax,[esi+00000090]
push [esi+00000094]
push eax
mov edx,[eax]
call dword ptr [edx+000000C8]
mov eax,[esi+00000090]
push 00 { 0 }
mov ecx,[eax]
push ecx
mov [esp],3F800000 { 1.00 }
push 01 { 1 }
push [esi+000000A0]
push eax
call dword ptr [ecx+000000D4]
mov ecx,[edi+04]
call CameraXDBVM
mov eax,[edi+04]
mov edx,[edi]
push 01 { 1 }
movups xmm0,[eax+20]
push [edx+00000170]
movaps [esp+68],xmm0
movups xmm0,[eax+30]
movaps [esp+78],xmm0
movups xmm0,[eax+40]
movaps [esp+00000088],xmm0
movups xmm0,[eax+50]
mov eax,[edx+00000090]
push eax
movaps [esp+0000009C],xmm0
movups xmm0,[edx+000000F0]
mov ecx,[eax]
movaps [esp+000000AC],xmm0
movups xmm0,[edx+00000100]
movaps [esp+000000BC],xmm0
movups xmm0,[edx+00000110]
movaps [esp+000000CC],xmm0
movups xmm0,[edx+00000120]
movaps [esp+000000DC],xmm0
movups xmm0,[edx+00000130]
movaps [esp+2C],xmm0
movups xmm0,[edx+00000140]
movaps [esp+3C],xmm0
movups xmm0,[edx+00000150]
movaps [esp+4C],xmm0
movups xmm0,[edx+00000160]
movaps [esp+5C],xmm0
call dword ptr [ecx+00000090]
mov eax,[edi]
sub esp,08 { 8 }
mov esi,[eax+00000090]
mov eax,[edi+0C]
mov ecx,eax
push esi
mov [esp+20],eax
call Dx11Demo_11.BitmapClass::UpdateBuffers
test al,al
je Dx11Demo_11.GraphicsClass::Render+176
mov eax,[esi]
lea ecx,[esp+18]
push ecx
lea ecx,[esp+14]
mov [esp+14],00000014 { 20 }
push ecx
push [esp+1C]
mov [esp+24],00000000 { 0 }
push 01 { 1 }
push 00 { 0 }
push esi
call dword ptr [eax+48]
mov ecx,[esp+14]
mov eax,[esi]
push 00 { 0 }
push 2A { 42 }
push [ecx+04]
push esi
call dword ptr [eax+4C]
mov eax,[esi]
push 04 { 4 }
push esi
call dword ptr [eax+60]
movaps xmm0,[esp+20]
mov ecx,[edi+0C]
movaps [esp+000000E0],xmm0
movaps xmm0,[esp+30]
movaps [esp+000000F0],xmm0
movaps xmm0,[esp+40]
mov eax,[ecx+10]
movaps [esp+00000100],xmm0
movaps xmm0,[esp+50]
movaps [esp+00000110],xmm0
mov edx,[eax]
movaps xmm0,[esp+60]
mov eax,[ecx+0C]
movaps [esp+00000120],xmm0
movaps xmm0,[esp+70]
movaps [esp+00000130],xmm0
movaps xmm0,[esp+00000080]
mov [esp+10],eax
mov eax,[edi]
mov edi,[edi+08]
mov ecx,edi
movaps [esp+00000140],xmm0
movaps xmm0,[esp+00000090]
mov esi,[eax+00000090]
lea eax,[esp+000000E0]
movaps [esp+00000150],xmm0
movaps xmm0,[esp+000000A0]
push edx
push eax
movaps [esp+00000168],xmm0
lea eax,[esp+00000128]
movaps xmm0,[esp+000000B8]
push eax
movaps [esp+0000017C],xmm0
lea eax,[esp+0000016C]
movaps xmm0,[esp+000000CC]
movaps [esp+0000018C],xmm0
movaps xmm0,[esp+000000DC]
push eax
push esi
movaps [esp+000001A4],xmm0
call Dx11Demo_11.TextureShaderClass::SetShaderParameters
test al,al
je Dx11Demo_11.GraphicsClass::Render+2A1
push [edi+08]
mov eax,[esi]
push esi
call dword ptr [eax+44]
mov eax,[esi]
push 00 { 0 }
push 00 { 0 }
push [edi]
push esi
call dword ptr [eax+2C]
mov eax,[esi]
push 00 { 0 }
push 00 { 0 }
push [edi+04]
push esi
call dword ptr [eax+24]
mov ecx,[esi]
lea eax,[edi+10]
push eax
push 01 { 1 }
push 00 { 0 }
push esi
call dword ptr [ecx+28]
mov eax,[esi]
push 00 { 0 }
push 00 { 0 }
push [esp+18]
push esi
call dword ptr [eax+30]
mov esi,[esp+1C]
push 01 { 1 }
mov eax,[esi]
mov ecx,[eax+00000090]
push [eax+0000009C]
push ecx
mov edx,[ecx]
call dword ptr [edx+00000090]
mov eax,[esi]
push 00 { 0 }
cmp byte ptr [eax],00 { 0 }
mov ecx,[eax+00000088]
mov edx,[ecx]
je Dx11Demo_11.GraphicsClass::Render+2DD
push 01 { 1 }
push ecx
call dword ptr [edx+20]
mov al,01 { 1 }
pop edi
pop esi
mov esp,ebp
pop ebp
ret
push 00 { 0 }
push ecx
call dword ptr [edx+20]
pop edi
mov al,01 { 1 }
pop esi
mov esp,ebp
pop ebp
ret


 createThread(ThX)

[DISABLE]
//code from here till the end of the code will be used to disable the cheat
</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>1042</ID>
      <Description>"No description"</Description>
      <LastState Value="00 00 C0 7F 00 00 C0 7F 00 00 C0 7F 00 00 C0 7F FF FF FF FF FF FF FF FF FF" RealAddress="0155B040"/>
      <ShowAsHex>1</ShowAsHex>
      <VariableType>Array of byte</VariableType>
      <ByteLength>25</ByteLength>
      <Address>Dx11Demo_11.exe+115B040</Address>
    </CheatEntry>
    <CheatEntry>
      <ID>1043</ID>
      <Description>"No description"</Description>
      <LastState Value="FF FF FF FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 3F 00 00 00 3F 00 00 00 3F 00 00 00 3F 83 F9 22 3E 83 F9 22 3E 83 F9 22 3E 83 F9 22 3E FF FF FF 7F FF FF FF 7F FF FF FF 7F FF FF FF" RealAddress="0155B050"/>
      <ShowAsHex>1</ShowAsHex>
      <VariableType>Array of byte</VariableType>
      <ByteLength>63</ByteLength>
      <Address>Dx11Demo_11.exe+115B050</Address>
    </CheatEntry>
    <CheatEntry>
      <ID>1044</ID>
      <Description>"No description"</Description>
      <LastState Value="00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 80 3F 00 00 00 00 00 00 80 3F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 3F 00 00 00" RealAddress="01541000"/>
      <ShowAsHex>1</ShowAsHex>
      <VariableType>Array of byte</VariableType>
      <ByteLength>59</ByteLength>
      <Address>Dx11Demo_11.exe+1141000</Address>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
</CheatTable>
